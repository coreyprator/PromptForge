{
  "files": [
    {
      "path": "app.py",
      "language": "python",
      "op": "write",
      "contents": "import hashlib\\nimport json\\nimport os\\nimport re\\nimport shutil\\nimport subprocess\\nimport tempfile\\nimport webbrowser\\nfrom pathlib import Path\\nimport tkinter as tk\\nfrom tkinter import filedialog, messagebox, ttk\\n\\nfrom pf.compliance_gate_t2 import validate as gate_t2_validate\\nfrom pf.change_journal import prepare_ops_for_apply, record_apply, undo_last\\n\\nPROJECT_ROOT = Path.cwd()\\nSCRIPTS_DIR = PROJECT_ROOT / \\"v2\\" / \\"scripts\\"\\nTOOLS_DIR = PROJECT_ROOT / \\"v2\\" / \\"tools\\"\\n\\nSCENARIOS = [\\n    (\\"setup_run_ui\\", \\"scenario_setup_run_ui.ps1\\"),\\n    (\\"standard_git_publish\\", \\"scenario_git_publish.ps1\\"),\\n    (\\"standard_test_and_lint\\", \\"scenario_test_and_lint.ps1\\"),\\n    (\\"venv_rebuild\\", \\"scenario_venv_rebuild.ps1\\"),\\n    (\\"venv_validate\\", \\"scenario_venv_validate.ps1\\"),\\n    (\\"tool_commands\\", \\"scenario_tool_commands.ps1\\")\\n]\\n\\nDEF_EDITOR = os.environ.get(\\"PF_EDITOR_CMD\\")  # e.g. \\"code -g {path}\\"\\nPY_EXE = os.environ.get(\\"PF_PY\\") or shutil.which(\\"py\\") or shutil.which(\\"python\\") or \\"python\\"\\n\\nURL_RE = re.compile(r'(https?://[^\\\\s\\\\]\\\\)]+)')\\nPATH_RE = re.compile(r'([A-Za-z]:\\\\\\\\[^\\\\s\\\\n\\\\r]+\\\\.(json|py|ps1|md|txt)|[A-Za-z]:/[^\\\\s\\\\n\\\\r]+\\\\.(json|py|ps1|md|txt)|/[^\\\\s\\\\n\\\\r]+\\\\.(json|py|ps1|md|txt))')\\n\\n\\ndef _run_pwsh_script(script_path: Path, *args):\\n    cmd = [\\"pwsh\\", \\"-NoProfile\\", \\"-File\\", str(script_path), *args]\\n    return subprocess.run(cmd, capture_output=True, text=True)\\n\\n\\ndef _apply_file(project_root: Path, f: dict):\\n    op = (f.get(\\"op\\") or \\"write\\").lower()\\n    path = project_root / f[\\"path\\"]\\n    path.parent.mkdir(parents=True, exist_ok=True)\\n    if op == \\"write\\":\\n        path.write_text(f.get(\\"contents\\") or \\"\\", encoding=\\"utf-8\\")\\n    elif op == \\"patch\\":\\n        if path.exists():\\n            existing = path.read_text(encoding=\\"utf-8\\")\\n            patch = f.get(\\"contents\\") or \\"\\\"\\n            if patch not in existing:\\n                path.write_text(existing + \\"\\\\n\\" + patch, encoding=\\"utf-8\\")\\n        else:\\n            path.write_text(f.get(\\"contents\\") or \\"\\", encoding=\\"utf-8\\")\\n    elif op == \\"delete\\":\\n        if path.exists():\\n            path.unlink()\\n    elif op == \\"rename\\":\\n        src = f.get(\\"from\\")\\n        dst = f.get(\\"to\\")\\n        if src and dst:\\n            (project_root / dst).parent.mkdir(parents=True, exist_ok=True)\\n            (project_root / src).replace(project_root / dst)\\n\\n\\ndef _basic_schema_validate(payload: dict) -> list[str]:\\n    errs: list[str] = []\\n    if not isinstance(payload, dict):\\n        return [\\"Payload must be a JSON object.\\"]\\n    files = payload.get(\\"files\\")\\n    if not isinstance(files, list) or not files:\\n        errs.append(\\"Payload.files must be a non-empty list.\\")\\n        return errs\\n    for i, f in enumerate(files):\\n        if not isinstance(f, dict):\\n            errs.append(f\\"files[{i}] must be an object.\\")\\n            continue\\n        for req in (\\"path\\", \\"op\\", \\"language\\"):\\n            if not f.get(req):\\n                errs.append(f\\"files[{i}].{req} is required.\\")\\n        if f.get(\\"op\\") not in (\\"write\\", \\"patch\\", \\"delete\\", \\"rename\\"):\\n            errs.append(\\"files[%d].op must be write|patch|delete|rename.\\" % i)\\n        if f.get(\\"op\\") in (\\"write\\", \\"patch\\") and \\"contents\\" not in f:\\n            errs.append(\\"files[%d].contents is required for op=%s.\\" % (i, f.get(\\"op\\")))\\n        if f.get(\\"op\\") == \\"rename\\" and (not f.get(\\"from\\") or not f.get(\\"to\\")):\\n            errs.append(\\"files[%d].from and .to required for op=rename.\\" % i)\\n    return errs\\n\\n\\nclass App(tk.Tk):\\n    def __init__(self) -> None:\\n        super().__init__()\\n        self.title(\\"PromptForge â€” V2.2 Test Rig\\")\\n        self.geometry(\\"1280x880\\")\\n        self.payload: dict | None = None\\n        self.payload_id: str | None = None\\n        self.auto_retry = True\\n\\n        toolbar = tk.Frame(self)\\n        toolbar.pack(fill=\\"x\\", padx=8, pady=6)\\n        tk.Button(toolbar, text=\\"Load JSON\\", command=self.load_json).pack(side=\\"left\\")\\n        tk.Button(toolbar, text=\\"Save JSON\\", command=self.save_json).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Validate Schema\\", command=self.validate_schema).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Run Compliance\\", command=self.run_gate).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Quick Fix\\", command=self.quick_fix).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Ruff Fix\\", command=self.ruff_fix).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Fix & Validate\\", command=self.fix_and_validate).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Apply\\", command=self.do_apply).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Undo\\", command=self.do_undo).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Open Latest Journal\\", command=self.open_latest_journal).pack(side=\\"left\\", padx=6)\\n        tk.Button(toolbar, text=\\"Retry\\", command=self.do_retry).pack(side=\\"left\\", padx=6)\\n\\n        tk.Label(toolbar, text=\\"Scenario:\\").pack(side=\\"left\\", padx=(24, 4))\\n        self.scenario_var = tk.StringVar(value=SCENARIOS[0][0])\\n        ttk.Combobox(toolbar, textvariable=self.scenario_var, values=[s[0] for s in SCENARIOS], width=28).pack(side=\\"left\\")\\n        tk.Button(toolbar, text=\\"Run Scenario\\", command=self.run_scenario).pack(side=\\"left\\", padx=6)\\n\\n        paned = tk.PanedWindow(self, sashrelief=\\"raised\\", orient=\\"horizontal\\")\\n        paned.pack(expand=True, fill=\\"both\\")\\n        left = tk.PanedWindow(paned, orient=\\"vertical\\")\\n        right = tk.PanedWindow(paned, orient=\\"vertical\\")\\n        paned.add(left)\\n        paned.add(right)\\n\\n        self.txt_parsed = self._panel(left, \\"Parsed A (Channel-A JSON)\\")\\n        self.txt_prose = self._panel(left, \\"Prose B (human narrative)\\")\\n        self.txt_errors = self._panel(right, \\"Errors / Logs\\")\\n\\n        self._log(\\"Project root: \\" + str(PROJECT_ROOT))\\n\\n    def _panel(self, parent, title: str) -> tk.Text:\\n        frame = tk.Frame(parent)\\n        parent.add(frame)\\n        tk.Label(frame, text=title, anchor=\\"w\\").pack(fill=\\"x\\")\\n        text = tk.Text(frame, wrap=\\"word\\", undo=True)\\n        text.pack(expand=True, fill=\\"both\\")\\n        return text\\n\\n    def _linkify(self, widget: tk.Text) -> None:\\n        content = widget.get(\\"1.0\\", \\"end\\")\\n        for match in URL_RE.finditer(content):\\n            self._tag_link(widget, match.start(), match.end(), match.group(1))\\n        for match in PATH_RE.finditer(content):\\n            self._tag_link(widget, match.start(1), match.end(1), match.group(1))\\n\\n    def _tag_link(self, widget: tk.Text, start: int, end: int, target: str) -> None:\\n        s = self._idx_to_text_index(widget, start)\\n        e = self._idx_to_text_index(widget, end)\\n        tag = f\\"link_{start}_{end}\\"\\n        widget.tag_add(tag, s, e)\\n        widget.tag_config(tag, foreground=\\"blue\\", underline=True)\\n        widget.tag_bind(tag, \\"<Button-1>\\", lambda _e, t=target: self._open_target(t))\\n\\n    def _idx_to_text_index(self, widget: tk.Text, n: int) -> str:\\n        content = widget.get(\\"1.0\\", \\"end\\")\\n        before = content[:n]\\n        line = before.count(\\"\\\\n\\") + 1\\n        col = len(before.rsplit(\\"\\\\n\\", 1)[-1]) + 1\\n        return f\\"{line}.{col}\\"\\n\\n    def _open_target(self, target: str) -> None:\\n        val = target.strip()\\n        if val.startswith(\\"http://\\") or val.startswith(\\"https://\\"):\\n            webbrowser.open(val)\\n            return\\n        path = Path(val)\\n        if DEF_EDITOR:\\n            cmd = DEF_EDITOR.format(path=str(path)) if \\"{path}\\" in DEF_EDITOR else f\\"{DEF_EDITOR} {path}\\"\\n            subprocess.Popen(cmd, shell=True)\\n            return\\n        if shutil.which(\\"code\\"):\\n            subprocess.Popen([\\"code\\", \\"-g\\", str(path)])\\n        elif os.name == \\"nt\\":\\n            os.startfile(str(path))  # type: ignore[attr-defined]\\n        else:\\n            subprocess.Popen([\\"xdg-open\\", str(path)])\\n\\n    def _log(self, msg: str) -> None:\\n        self.txt_errors.insert(\\"end\\", msg + \\"\\\\n\\")\\n        self.txt_errors.see(\\"end\\")\\n        self._linkify(self.txt_errors)\\n\\n    def _prose(self, msg: str) -> None:\\n        self.txt_prose.insert(\\"end\\", msg + \\"\\\\n\\")\\n        self.txt_prose.see(\\"end\\")\\n        self._linkify(self.txt_prose)\\n\\n    def load_json(self) -> None:\\n        path = filedialog.askopenfilename(title=\\"Select Channel-A JSON\\", filetypes=[(\\"JSON files\\", \\"*.json\\"), (\\"All files\\", \\"*.*\\")])\\n        if not path:\\n            return\\n        with open(path, \\"r\\", encoding=\\"utf-8\\") as handle:\\n            self.payload = json.load(handle)\\n        self.txt_parsed.delete(\\"1.0\\", \\"end\\")\\n        self.txt_parsed.insert(\\"1.0\\", json.dumps(self.payload, indent=2, ensure_ascii=False))\\n        self._log(f\\"Loaded payload: {path}\\")\\n\\n    def save_json(self) -> None:\\n        if not self.payload:\\n            try:\\n                self.payload = json.loads(self.txt_parsed.get(\\"1.0\\", \\"end\\").strip())\\n            except Exception as exc:\\n                messagebox.showerror(\\"Save JSON\\", f\\"No valid JSON loaded/typed.\\\\n{exc}\\")\\n                return\\n        dest = filedialog.asksaveasfilename(defaultextension=\\".json\\", filetypes=[(\\"JSON\\", \\"*.json\\")])\\n        if not dest:\\n            return\\n        with open(dest, \\"w\\", encoding=\\"utf-8\\") as handle:\\n            json.dump(self.payload, handle, indent=2, ensure_ascii=False)\\n        self._log(f\\"Saved payload: {dest}\\")\\n\\n    def _read_payload_from_editor(self) -> dict | None:\\n        try:\\n            return json.loads(self.txt_parsed.get(\\"1.0\\", \\"end\\").strip())\\n        except Exception as exc:\\n            messagebox.showerror(\\"Invalid JSON\\", str(exc))\\n            return None\\n\\n    def _compute_payload_id(self, payload: dict) -> str:\\n        norm = json.dumps(payload, sort_keys=True, ensure_ascii=False)\\n        return hashlib.sha256(norm.encode(\\"utf-8\\")).hexdigest()[:8]\\n\\n    def validate_schema(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        errs = _basic_schema_validate(payload)\\n        if errs:\\n            self._log(\\"SCHEMA: FAIL\\")\\n            for e in errs:\\n                self._log(\\" - \\" + e)\\n            messagebox.showerror(\\"Schema\\", \\"FAIL â€” see Errors panel\\")\\n        else:\\n            self.payload_id = self._compute_payload_id(payload)\\n            msg = f\\"SCHEMA: PASS â€” PayloadID: {self.payload_id}\\"\\n            self._log(msg)\\n            self._prose(msg)\\n            messagebox.showinfo(\\"Schema\\", msg)\\n        self.payload = payload\\n\\n    def run_gate(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        res = gate_t2_validate(payload)\\n        if res[\\"pass\\"]:\\n            self._log(\\"Compliance Gate: PASS\\")\\n            messagebox.showinfo(\\"Compliance\\", \\"PASS\\")\\n        else:\\n            self._log(\\"Compliance Gate: FAIL\\")\\n            for e in res[\\"errors\\"]:\\n                self._log(e)\\n            messagebox.showerror(\\"Compliance\\", \\"FAIL â€” see Errors panel\\")\\n        self.payload = payload\\n\\n    def quick_fix(self) -> None:\\n        raw = self.txt_parsed.get(\\"1.0\\", \\"end\\").strip()\\n        if not raw:\\n            messagebox.showerror(\\"Quick Fix\\", \\"No JSON in Parsed panel.\\")\\n            return\\n        try:\\n            json.loads(raw)\\n        except Exception:\\n            messagebox.showerror(\\"Quick Fix\\", \\"Invalid JSON in Parsed panel.\\")\\n            return\\n        tmp_in = PROJECT_ROOT / \\"v2\\" / \\"samples\\" / \\"_last_fix_input.json\\"\\n        tmp_out = PROJECT_ROOT / \\"v2\\" / \\"samples\\" / \\"_last_fix_input.fixed.json\\"\\n        tmp_in.parent.mkdir(parents=True, exist_ok=True)\\n        tmp_in.write_text(raw, encoding=\\"utf-8\\")\\n\\n        fixer = TOOLS_DIR / \\"fix_channel_a.py\\"\\n        if not fixer.exists():\\n            messagebox.showerror(\\"Quick Fix\\", f\\"Missing fixer: {fixer}\\")\\n            return\\n\\n        if str(PY_EXE).endswith(\\"py\\") or str(PY_EXE).endswith(\\"py.exe\\"):\\n            cmd = [PY_EXE, \\"-3.12\\", str(fixer), \\"-i\\", str(tmp_in), \\"-o\\", str(tmp_out), \\"--report-json-only\\"]\\n        else:\\n            cmd = [PY_EXE, str(fixer), \\"-i\\", str(tmp_in), \\"-o\\", str(tmp_out), \\"--report-json-only\\"]\\n        proc = subprocess.run(cmd, capture_output=True, text=True)\\n        if proc.returncode not in (0,):\\n            self._log(\\"Quick Fix failed:\\")\\n            self._log(proc.stdout)\\n            self._log(proc.stderr)\\n            messagebox.showerror(\\"Quick Fix\\", \\"Failed â€” see Errors panel\\")\\n            return\\n        try:\\n            report = json.loads(proc.stdout.strip() or \\"{}\\")\\n        except Exception:\\n            report = {\\"status\\": \\"unknown\\", \\"messages\\": [proc.stdout.strip()]}\\n\\n        status = report.get(\\"status\\", \\"unknown\\")\\n        outp = report.get(\\"output_path\\", str(tmp_out))\\n        msgs = report.get(\\"messages\\", [])\\n\\n        if Path(outp).exists():\\n            fixed = json.loads(Path(outp).read_text(encoding=\\"utf-8\\"))\\n            self.payload = fixed\\n            self.txt_parsed.delete(\\"1.0\\", \\"end\\")\\n            self.txt_parsed.insert(\\"1.0\\", json.dumps(fixed, indent=2, ensure_ascii=False))\\n\\n        changed = [m for m in msgs if (\\"defaulted\\" in m or \\"inferred\\" in m or \\"filled\\" in m)]\\n        prose_msg = f\\"Quick Fix: {status.upper()}. Wrote: {outp}\\"\\n        if changed:\\n            prose_msg += \\"\\\\nChanges:\\\\n - \\" + \\"\\\\n - \\".join(changed)\\n        self._prose(prose_msg)\\n        self._log(\\"Quick Fix report: \\" + json.dumps(report, ensure_ascii=False))\\n        messagebox.showinfo(\\"Quick Fix\\", f\\"Fixed payload written to:\\\\n{outp}\\")\\n\\n    def ruff_fix(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        ruff = shutil.which(\\"ruff\\")\\n        if not ruff:\\n            messagebox.showerror(\\"Ruff Fix\\", \\"ruff is not on PATH.\\")\\n            return\\n        tmpdir = Path(tempfile.mkdtemp(prefix=\\"pf_rufffix_\\", dir=str(PROJECT_ROOT / \\".pf\\") if (PROJECT_ROOT / \\".pf\\").exists() else None))\\n        changed_count = 0\\n        details: list[str] = []\\n        for idx, f in enumerate(payload.get(\\"files\\", [])):\\n            lang = (f.get(\\"language\\") or \\"\\").lower()\\n            src = f.get(\\"contents\\")\\n            if lang not in (\\"python\\", \\"py\\") or src is None:\\n                continue\\n            tpath = tmpdir / f\\"snippet_{idx}.py\\"\\n            tpath.write_text(src, encoding=\\"utf-8\\")\\n            subprocess.run([ruff, \\"check\\", \\"--fix\\", str(tpath)], capture_output=True, text=True)\\n            new_src = tpath.read_text(encoding=\\"utf-8\\")\\n            if new_src != src:\\n                payload[\\"files\\"][idx][\\"contents\\"] = new_src\\n                changed_count += 1\\n                details.append(f\\"files[{idx}] fixed via ruff --fix -> {tpath.name}\\")\\n        if changed_count:\\n            self.payload = payload\\n            self.txt_parsed.delete(\\"1.0\\", \\"end\\")\\n            self.txt_parsed.insert(\\"1.0\\", json.dumps(payload, indent=2, ensure_ascii=False))\\n            msg = f\\"Ruff Fix: updated {changed_count} Python file(s) in payload.\\"\\n            self._prose(msg)\\n            if details:\\n                self._log(\\"; \\".join(details))\\n            messagebox.showinfo(\\"Ruff Fix\\", msg)\\n        else:\\n            messagebox.showinfo(\\"Ruff Fix\\", \\"No Python files changed.\\")\\n\\n    def fix_and_validate(self) -> None:\\n        # Chain Quick Fix -> Ruff Fix -> Compliance with a single summary\\n        self.quick_fix()\\n        self.ruff_fix()\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        res = gate_t2_validate(payload)\\n        if res[\\"pass\\"]:\\n            msg = \\"Fix & Validate: PASS â€” ready to Apply.\\"\\n            self._prose(msg)\\n            messagebox.showinfo(\\"Fix & Validate\\", msg)\\n        else:\\n            self._log(\\"Fix & Validate: Compliance FAIL\\")\\n            for e in res[\\"errors\\"]:\\n                self._log(e)\\n            messagebox.showerror(\\"Fix & Validate\\", \\"Compliance FAIL â€” see Errors panel\\")\\n\\n    def do_apply(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        s_errs = _basic_schema_validate(payload)\\n        if s_errs:\\n            self._log(\\"Apply blocked â€” schema invalid.\\")\\n            for e in s_errs:\\n                self._log(\\" - \\" + e)\\n            messagebox.showerror(\\"Apply\\", \\"Blocked by Schema.\\")\\n            return\\n        res = gate_t2_validate(payload)\\n        if not res[\\"pass\\"]:\\n            self._log(\\"Apply blocked â€” compliance failed.\\")\\n            for e in res[\\"errors\\"]:\\n                self._log(e)\\n            if self.auto_retry:\\n                self._log(\\"Tip: use Fix & Validate, then Retry.\\")\\n            messagebox.showerror(\\"Apply\\", \\"Blocked by Compliance Gate.\\")\\n            return\\n        files = payload.get(\\"files\\", [])\\n        ops = prepare_ops_for_apply(PROJECT_ROOT, files)\\n        for f in files:\\n            _apply_file(PROJECT_ROOT, f)\\n        jf = record_apply(PROJECT_ROOT, ops)\\n        journal_id = jf.stem\\n        msg = f\\"APPLY: PASS â€” JournalID: {journal_id}\\\\nPath: {jf}\\"\\n        self._log(msg)\\n        self._prose(msg)\\n        messagebox.showinfo(\\"Apply\\", msg)\\n        self.payload = payload\\n\\n    def open_latest_journal(self) -> None:\\n        jroot = PROJECT_ROOT / \\".pf\\" / \\"journal\\"\\n        if not jroot.exists():\\n            messagebox.showwarning(\\"Journal\\", \\"No .pf/journal found yet.\\")\\n            return\\n        files = sorted(jroot.glob(\\"*.jsonl\\"))\\n        if not files:\\n            messagebox.showwarning(\\"Journal\\", \\"No journal entries yet.\\")\\n            return\\n        latest = files[-1]\\n        # Reuse the same opener as link clicks\\n        self._open_target(str(latest))\\n        self._prose(f\\"Opened latest journal: {latest}\\")\\n\\n    def do_undo(self) -> None:\\n        res = undo_last(PROJECT_ROOT)\\n        if res.get(\\"ok\\"):\\n            self._log(res[\\"message\\"])\\n            messagebox.showinfo(\\"Undo\\", res[\\"message\\"])\\n        else:\\n            self._log(res[\\"message\\"])\\n            messagebox.showwarning(\\"Undo\\", res[\\"message\\"])\\n\\n    def do_retry(self) -> None:\\n        if not self.payload:\\n            self._log(\\"Nothing to retry.\\")\\n            return\\n        res = gate_t2_validate(self.payload)\\n        if res[\\"pass\\"]:\\n            self._log(\\"Retry: Compliance Gate now PASS\\")\\n        else:\\n            self._log(\\"Retry: still FAIL\\")\\n            for e in res[\\"errors\\"]:\\n                self._log(e)\\n\\n    def run_scenario(self) -> None:\\n        name = self.scenario_var.get()\\n        match = next((m for m in SCENARIOS if m[0] == name), None)\\n        if not match:\\n            messagebox.showerror(\\"Scenario\\", f\\"Unknown scenario: {name}\\")\\n            return\\n        script = SCRIPTS_DIR / match[1]\\n        if not script.exists():\\n            self._log(f\\"Scenario script not found: {script}\\")\\n            messagebox.showerror(\\"Scenario\\", f\\"Missing: {script.name}\\")\\n            return\\n        result = _run_pwsh_script(script, \\"-ProjectRoot\\", str(PROJECT_ROOT))\\n        if result.returncode == 0:\\n            self._log(f\\"[{name}] OK\\")\\n            if result.stdout.strip():\\n                self._log(result.stdout.strip())\\n            messagebox.showinfo(\\"Scenario\\", f\\"{name}: OK\\")\\n        else:\\n            self._log(f\\"[{name}] FAIL ({result.returncode})\\")\\n            if result.stdout.strip():\\n                self._log(result.stdout.strip())\\n            if result.stderr.strip():\\n                self._log(result.stderr.strip())\\n            messagebox.showerror(\\"Scenario\\", f\\"{name}: FAIL â€” see Errors panel\\")\\n\\n\\nif __name__ == \\"__main__\\":\\n    App().mainloop()\\n"
    }
  ]
}
