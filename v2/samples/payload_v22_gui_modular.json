{
  "files": [
    {
      "path": "app.py",
      "language": "python",
      "op": "write",
      "contents": "from pf.ui_app import App\n\nif __name__ == \"__main__\":\n    App().mainloop()\n"
    },
    {
      "path": "pf/__init__.py",
      "language": "python",
      "op": "write",
      "contents": ""
    },
    {
      "path": "pf/registry.py",
      "language": "python",
      "op": "write",
      "contents": "import json, os\nfrom pathlib import Path\n\n\ndef _registry_dir() -> Path:\n    appdata = os.environ.get(\"APPDATA\")\n    return (Path(appdata) / \"PromptForge\") if appdata else (Path.home() / \".promptforge\")\n\n\ndef _registry_path() -> Path:\n    p = _registry_dir(); p.mkdir(parents=True, exist_ok=True); return p / \"projects.json\"\n\n\ndef load_registry() -> list[str]:\n    p = _registry_path()\n    try:\n        if p.exists():\n            data = json.loads(p.read_text(encoding=\"utf-8\"))\n            if isinstance(data, list):\n                return [str(Path(x)) for x in data]\n    except Exception:\n        pass\n    return []\n\n\ndef save_registry(items: list[str]) -> None:\n    p = _registry_path()\n    uniq, seen = [], set()\n    for x in items:\n        x = str(Path(x))\n        if x not in seen:\n            seen.add(x); uniq.append(x)\n    p.write_text(json.dumps(uniq, indent=2, ensure_ascii=False), encoding=\"utf-8\")\n"
    },
    {
      "path": "pf/utils.py",
      "language": "python",
      "op": "write",
      "contents": "import json, re, shutil, subprocess\nfrom pathlib import Path\n\nURL_RE  = re.compile(r\"(https?://\\S+)\")\nPATH_RE = re.compile(r\"((?:[A-Za-z]:[\\\\/]|/)[^\\s\\r\\n]+)\")\nTRAILING_JUNK_RE = re.compile(r\"[)\\]\\}.,;'\\\"]+$\")\n\n\ndef load_project_config(root: Path) -> dict:\n    cfg = root / \".pf\" / \"project.json\"\n    try:\n        if cfg.exists():\n            return json.loads(cfg.read_text(encoding=\"utf-8\"))\n    except Exception:\n        pass\n    return {\n        \"version\": \"2.2\",\n        \"retry_policy\": {\"auto_retries\": 1, \"manual_retry\": True},\n        \"undo\": {\"mode\": \"history\"},\n        \"scenarios\": {\"system\": [\n            \"setup_run_ui\",\"venv_validate\",\"standard_test_and_lint\",\"tool_commands\",\"standard_git_publish\"\n        ]}\n    }\n\n\ndef run_pwsh_script(script_path: Path, *args):\n    cmd = [\"pwsh\",\"-NoProfile\",\"-File\",str(script_path),*args]\n    return subprocess.run(cmd, capture_output=True, text=True, encoding=\"utf-8\", errors=\"replace\")\n\n\ndef apply_file(project_root: Path, f: dict):\n    op = (f.get(\"op\") or \"write\").lower()\n    path = project_root / f[\"path\"]; path.parent.mkdir(parents=True, exist_ok=True)\n    if op == \"write\":\n        path.write_text(f.get(\"contents\") or \"\", encoding=\"utf-8\")\n    elif op == \"patch\":\n        if path.exists():\n            existing = path.read_text(encoding=\"utf-8\"); patch = f.get(\"contents\") or \"\"\n            if patch not in existing: path.write_text(existing+\"\\n\"+patch, encoding=\"utf-8\")\n        else:\n            path.write_text(f.get(\"contents\") or \"\", encoding=\"utf-8\")\n    elif op == \"delete\":\n        if path.exists(): path.unlink()\n    elif op == \"rename\":\n        src=f.get(\"from\"); dst=f.get(\"to\")\n        if src and dst:\n            (project_root/dst).parent.mkdir(parents=True, exist_ok=True)\n            (project_root/src).replace(project_root/dst)\n\n\ndef basic_schema_validate(payload: dict) -> list[str]:\n    errs=[]\n    if not isinstance(payload, dict): return [\"Payload must be a JSON object.\"]\n    files = payload.get(\"files\")\n    if not isinstance(files, list) or not files:\n        errs.append(\"Payload.files must be a non-empty list.\"); return errs\n    for i,f in enumerate(files):\n        if not isinstance(f, dict): errs.append(f\"files[{i}] must be an object.\"); continue\n        for req in (\"path\",\"op\",\"language\"):\n            if not f.get(req): errs.append(f\"files[{i}].{req} is required.\")\n        if f.get(\"op\") not in (\"write\",\"patch\",\"delete\",\"rename\"):\n            errs.append(\"files[%d].op must be write|patch|delete|rename.\" % i)\n        if f.get(\"op\") in (\"write\",\"patch\") and \"contents\" not in f:\n            errs.append(\"files[%d].contents is required for op=%s.\" % (i, f.get(\"op\")))\n        if f.get(\"op\") == \"rename\" and (not f.get(\"from\") or not f.get(\"to\")):\n            errs.append(\"files[%d].from and .to required for op=rename.\" % i)\n    return errs\n"
    },
    {
      "path": "pf/ui_app.py",
      "language": "python",
      "op": "write",
      "contents": "import hashlib, json, os, shutil, subprocess, tempfile, webbrowser\nfrom pathlib import Path\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox, ttk\n\nfrom pf.compliance_gate_t2 import validate as gate_t2_validate\nfrom pf.change_journal import prepare_ops_for_apply, record_apply, undo_last\nfrom pf.registry import load_registry, save_registry\nfrom pf.utils import URL_RE, PATH_RE, TRAILING_JUNK_RE, load_project_config, run_pwsh_script, apply_file, basic_schema_validate\n\n\nclass App(tk.Tk):\n    def __init__(self) -> None:\n        super().__init__()\n        self.title(\"PromptForge — V2.2 Test Rig\"); self.geometry(\"1320x940\")\n        # project state\n        self.project_root: Path = Path.cwd()\n        self.scripts_dir = self.project_root / \"v2\" / \"scripts\"\n        self.tools_dir   = self.project_root / \"v2\" / \"tools\"\n        self.config_data = load_project_config(self.project_root)\n        reg = load_registry()\n        if str(self.project_root) not in reg:\n            reg.insert(0, str(self.project_root)); save_registry(reg)\n        self.payload=None; self.payload_id=None\n        self.auto_retry = bool(self.config_data.get(\"retry_policy\",{}).get(\"auto_retries\",1))\n\n        # toolbar\n        tb = tk.Frame(self); tb.pack(fill=\"x\", padx=8, pady=6)\n        tk.Label(tb, text=\"Project:\").pack(side=\"left\")\n        self.project_var = tk.StringVar(value=str(self.project_root))\n        self.project_combo = ttk.Combobox(tb, textvariable=self.project_var, width=54)\n        self._refresh_projects_combo(); self.project_combo.pack(side=\"left\", padx=(4,6))\n        tk.Button(tb, text=\"Open\",   command=self._project_open_selected).pack(side=\"left\")\n        tk.Button(tb, text=\"Add…\",   command=self._project_add).pack(side=\"left\", padx=(4,0))\n        tk.Button(tb, text=\"New…\",   command=self._project_new).pack(side=\"left\", padx=(4,0))\n        tk.Button(tb, text=\"Remove\", command=self._project_remove_selected).pack(side=\"left\", padx=(4,12))\n        tk.Button(tb, text=\"Reload\", command=self._project_reload).pack(side=\"left\", padx=(0,16))\n\n        tk.Label(tb, text=\"Scenario:\").pack(side=\"left\")\n        self.scenario_var = tk.StringVar(value=\"\")\n        self.scenario_combo = ttk.Combobox(tb, textvariable=self.scenario_var, width=28)\n        self._refresh_scenarios(); self.scenario_combo.pack(side=\"left\", padx=(4,6))\n        tk.Button(tb, text=\"Run Scenario\", command=self.run_scenario).pack(side=\"left\", padx=6)\n\n        # Channel-A actions\n        tk.Button(tb, text=\"Load JSON\",        command=self.load_json).pack(side=\"left\", padx=(18,0))\n        tk.Button(tb, text=\"Save JSON\",        command=self.save_json).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Validate Schema\",  command=self.validate_schema).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Run Compliance\",   command=self.run_gate).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Quick Fix\",        command=self.quick_fix).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Ruff Fix\",         command=self.ruff_fix).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Fix & Validate\",   command=self.fix_and_validate).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Apply\",            command=self.do_apply).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Undo\",             command=self.do_undo).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Open Latest Journal\", command=self.open_latest_journal).pack(side=\"left\", padx=6)\n        tk.Button(tb, text=\"Retry\",            command=self.do_retry).pack(side=\"left\", padx=6)\n\n        # panes\n        paned = tk.PanedWindow(self, sashrelief=\"raised\", orient=\"horizontal\"); paned.pack(expand=True, fill=\"both\")\n        left = tk.PanedWindow(paned, orient=\"vertical\"); right = tk.PanedWindow(paned, orient=\"vertical\")\n        paned.add(left); paned.add(right)\n        self.txt_parsed = self._panel(left, \"Parsed A (Channel-A JSON)\")\n        self.txt_prose  = self._panel(left, \"Prose B (human narrative)\")\n        self.txt_errors = self._panel(right, \"Errors / Logs\")\n        self._attach_context_menu(self.txt_parsed); self._attach_context_menu(self.txt_prose); self._attach_context_menu(self.txt_errors)\n        self._log(\"Project root: \" + str(self.project_root))\n        self._prose(\"Config loaded from .pf/project.json (if present). Auto-retry: \" + (\"on\" if self.auto_retry else \"off\"))\n\n    # ---- project ----\n    def _set_project_root(self, new_root: Path) -> None:\n        new_root = new_root.resolve()\n        if not new_root.exists():\n            messagebox.showerror(\"Project\", f\"Folder not found:\\n{new_root}\"); return\n        self.project_root = new_root\n        self.scripts_dir  = self.project_root / \"v2\" / \"scripts\"\n        self.tools_dir    = self.project_root / \"v2\" / \"tools\"\n        self.config_data  = load_project_config(self.project_root)\n        self.auto_retry   = bool(self.config_data.get(\"retry_policy\",{}).get(\"auto_retries\",1))\n        self._refresh_scenarios(); self._log(\"Switched project → \"+str(self.project_root))\n        self._prose(\"Project changed. Auto-retry: \"+(\"on\" if self.auto_retry else \"off\"))\n\n    def _refresh_projects_combo(self) -> None:\n        reg = load_registry()\n        if str(self.project_root) not in reg: reg.insert(0, str(self.project_root)); save_registry(reg)\n        self.project_combo[\"values\"] = reg; self.project_var.set(str(self.project_root))\n\n    def _project_open_selected(self) -> None:\n        self._set_project_root(Path(self.project_var.get().strip('\"'))); self._refresh_projects_combo()\n\n    def _project_add(self) -> None:\n        d = filedialog.askdirectory(title=\"Add project folder\");\n        if not d: return\n        p = str(Path(d)); reg = load_registry()\n        if p not in reg: reg.insert(0, p); save_registry(reg)\n        self._set_project_root(Path(p)); self._refresh_projects_combo()\n\n    def _project_new(self) -> None:\n        d = filedialog.askdirectory(title=\"Create/select folder for NEW project\");\n        if not d: return\n        root = Path(d); (root/\".pf\"/\"journal\").mkdir(parents=True, exist_ok=True)\n        cfg = root/\".pf\"/\"project.json\"\n        if not cfg.exists():\n            starter = load_project_config(root); cfg.write_text(json.dumps(starter, indent=2, ensure_ascii=False), encoding=\"utf-8\")\n        try:\n            if not (root/\"v2\"/\"scripts\").exists() and self.scripts_dir.exists(): shutil.copytree(self.scripts_dir, root/\"v2\"/\"scripts\")\n        except Exception:\n            (root/\"v2\"/\"scripts\").mkdir(parents=True, exist_ok=True)\n        try:\n            if not (root/\"v2\"/\"tools\").exists() and self.tools_dir.exists(): shutil.copytree(self.tools_dir, root/\"v2\"/\"tools\")\n        except Exception:\n            (root/\"v2\"/\"tools\").mkdir(parents=True, exist_ok=True)\n        reg = load_registry(); sp = str(root)\n        if sp not in reg: reg.insert(0, sp); save_registry(reg)\n        self._set_project_root(root); self._refresh_projects_combo(); messagebox.showinfo(\"New Project\", f\"Initialized project at:\\n{root}\")\n\n    def _project_remove_selected(self) -> None:\n        sel = self.project_var.get().strip(); reg = load_registry()\n        if sel in reg: reg.remove(sel); save_registry(reg)\n        if sel == str(self.project_root):\n            reg = load_registry(); new_root = Path(reg[0]) if reg else Path.cwd(); self._set_project_root(new_root)\n        self._refresh_projects_combo()\n\n    def _project_reload(self) -> None:\n        self._set_project_root(self.project_root)\n\n    # ---- UI helpers ----\n    def _panel(self, parent, title: str) -> tk.Text:\n        frame = tk.Frame(parent); parent.add(frame); tk.Label(frame, text=title, anchor=\"w\").pack(fill=\"x\")\n        text = tk.Text(frame, wrap=\"word\", undo=True); text.pack(expand=True, fill=\"both\"); return text\n\n    def _attach_context_menu(self, widget: tk.Text) -> None:\n        menu = tk.Menu(widget, tearoff=0)\n        menu.add_command(label=\"Copy\",  command=lambda w=widget: w.event_generate(\"<<Copy>>\"))\n        menu.add_command(label=\"Paste\", command=lambda w=widget: w.event_generate(\"<<Paste>>\"))\n        menu.add_command(label=\"Cut\",   command=lambda w=widget: w.event_generate(\"<<Cut>>\"))\n        menu.add_separator(); menu.add_command(label=\"Select All\", command=lambda w=widget: w.tag_add(\"sel\",\"1.0\",\"end-1c\"))\n        menu.add_command(label=\"Open Selection\", command=lambda w=widget: self._open_selection(w))\n        def show(evt):\n            try: menu.tk_popup(evt.x_root, evt.y_root)\n            finally: menu.grab_release()\n        widget.bind(\"<Button-3>\", show); widget.bind(\"<Control-Button-1>\", show)\n\n    def _open_selection(self, widget: tk.Text) -> None:\n        try: sel = widget.get(\"sel.first\",\"sel.last\").strip()\n        except tk.TclError: sel = \"\"\n        if sel: self._open_target(sel)\n\n    def _linkify(self, widget: tk.Text) -> None:\n        content = widget.get(\"1.0\",\"end\")\n        for m in URL_RE.finditer(content): self._tag_link(widget, m.start(), m.end(), m.group(1))\n        for m in PATH_RE.finditer(content): self._tag_link(widget, m.start(1), m.end(1), m.group(1))\n\n    def _tag_link(self, widget: tk.Text, start: int, end: int, target: str) -> None:\n        s = self._idx(widget,start); e = self._idx(widget,end); tag=f\"link_{start}_{end}\"\n        widget.tag_add(tag,s,e); widget.tag_config(tag,foreground=\"blue\",underline=True)\n        widget.tag_bind(tag,\"<Enter>\", lambda _e: widget.config(cursor=\"hand2\"))\n        widget.tag_bind(tag,\"<Leave>\", lambda _e: widget.config(cursor=\"\"))\n        widget.tag_bind(tag,\"<Button-1>\", lambda _e, t=target: self._open_target(t))\n\n    def _idx(self, widget: tk.Text, n: int) -> str:\n        content = widget.get(\"1.0\",\"end\"); before = content[:n]\n        return f\"{before.count('\\n')+1}.{len(before.rsplit('\\n',1)[-1])+1}\"\n\n    def _open_target(self, target: str) -> None:\n        val = TRAILING_JUNK_RE.sub(\"\", target.strip())\n        if val.startswith(\"http://\") or val.startswith(\"https://\"):\n            webbrowser.open(val); return\n        path = Path(val)\n        editor = os.environ.get(\"PF_EDITOR_CMD\")\n        if editor:\n            cmd = editor.format(path=str(path)) if \"{path}\" in editor else f\"{editor} {path}\"\n            subprocess.Popen(cmd, shell=True); return\n        code = shutil.which(\"code\")\n        if code:\n            try:\n                subprocess.Popen([code, \"-g\", str(path)]) if path.is_file() else subprocess.Popen([code, str(path if path.exists() else path.parent)])\n                return\n            except Exception:\n                pass\n        if os.name == \"nt\":\n            try:\n                subprocess.Popen([\"explorer\",\"/select,\",str(path)]) if path.is_file() else subprocess.Popen([\"explorer\", str(path if path.exists() else path.parent)])\n                return\n            except Exception:\n                pass\n        try:\n            if hasattr(os, \"startfile\"): os.startfile(str(path))  # type: ignore[attr-defined]\n            else: subprocess.Popen([\"xdg-open\", str(path)])\n        except Exception as exc:\n            messagebox.showerror(\"Open\", f\"Failed to open:\\n{path}\\n\\n{exc}\")\n\n    def _log(self, msg: str) -> None:\n        self.txt_errors.insert(\"end\", msg+\"\\n\"); self.txt_errors.see(\"end\"); self._linkify(self.txt_errors)\n\n    def _prose(self, msg: str) -> None:\n        self.txt_prose.insert(\"end\", msg+\"\\n\"); self.txt_prose.see(\"end\"); self._linkify(self.txt_prose)\n\n    # ---- scenarios ----\n    def _refresh_scenarios(self) -> None:\n        sys_list = list(self.config_data.get(\"scenarios\",{}).get(\"system\",[]))\n        proj_list = list(self.config_data.get(\"scenarios\",{}).get(\"project\",[]))\n        names = sys_list + [n for n in proj_list if n not in sys_list]\n        if not names:\n            names = [\"setup_run_ui\",\"venv_validate\",\"standard_test_and_lint\",\"tool_commands\",\"standard_git_publish\"]\n        self.scenario_combo[\"values\"] = names; self.scenario_var.set(names[0])\n\n    def _scenario_script_for(self, name: str) -> Path:\n        return self.scripts_dir / f\"scenario_{name}.ps1\"\n\n    # ---- file actions ----\n    def load_json(self) -> None:\n        path = filedialog.askopenfilename(title=\"Select Channel-A JSON\", filetypes=[(\"JSON files\",\"*.json\"),(\"All files\",\"*.*\")])\n        if not path: return\n        with open(path,\"r\",encoding=\"utf-8\") as h: self.payload = json.load(h)\n        self.txt_parsed.delete(\"1.0\",\"end\"); self.txt_parsed.insert(\"1.0\", json.dumps(self.payload, indent=2, ensure_ascii=False))\n        self._log(f\"Loaded payload: {path}\")\n\n    def save_json(self) -> None:\n        if not self.payload:\n            try: self.payload = json.loads(self.txt_parsed.get(\"1.0\",\"end\").strip())\n            except Exception as exc:\n                messagebox.showerror(\"Save JSON\", f\"No valid JSON loaded/typed.\\n{exc}\"); return\n        dest = filedialog.asksaveasfilename(defaultextension=\".json\", filetypes=[(\"JSON\",\"*.json\")])\n        if not dest: return\n        with open(dest,\"w\",encoding=\"utf-8\") as h: json.dump(self.payload, h, indent=2, ensure_ascii=False)\n        self._log(f\"Saved payload: {dest}\")\n\n    def _read_payload_from_editor(self) -> dict | None:\n        try: return json.loads(self.txt_parsed.get(\"1.0\",\"end\").strip())\n        except Exception as exc:\n            messagebox.showerror(\"Invalid JSON\", str(exc)); return None\n\n    def _compute_payload_id(self, payload: dict) -> str:\n        norm = json.dumps(payload, sort_keys=True, ensure_ascii=False)\n        return hashlib.sha256(norm.encode(\"utf-8\")).hexdigest()[:8]\n\n    def validate_schema(self) -> None:\n        payload = self._read_payload_from_editor(); \n        if not payload: return\n        errs = basic_schema_validate(payload)\n        if errs:\n            self._log(\"SCHEMA: FAIL\"); [self._log(\" - \"+e) for e in errs]; messagebox.showerror(\"Schema\",\"FAIL — see Errors panel\")\n        else:\n            self.payload_id = self._compute_payload_id(payload)\n            msg = f\"SCHEMA: PASS — PayloadID: {self.payload_id}\"; self._log(msg); self._prose(msg); messagebox.showinfo(\"Schema\", msg)\n        self.payload = payload\n\n    def run_gate(self) -> None:\n        payload = self._read_payload_from_editor(); \n        if not payload: return\n        res = gate_t2_validate(payload)\n        if res.get(\"pass\"): self._log(\"Compliance Gate: PASS\"); messagebox.showinfo(\"Compliance\",\"PASS\")\n        else:\n            self._log(\"Compliance Gate: FAIL\"); [self._log(e) for e in res.get(\"errors\",[])]; messagebox.showerror(\"Compliance\",\"FAIL — see Errors panel\")\n        self.payload = payload\n\n    def quick_fix(self) -> None:\n        raw = self.txt_parsed.get(\"1.0\",\"end\").strip()\n        if not raw: messagebox.showerror(\"Quick Fix\",\"No JSON in Parsed panel.\"); return\n        try: json.loads(raw)\n        except Exception: messagebox.showerror(\"Quick Fix\",\"Invalid JSON in Parsed panel.\"); return\n        tmp_in  = self.project_root/\"v2\"/\"samples\"/\"_last_fix_input.json\"\n        tmp_out = self.project_root/\"v2\"/\"samples\"/\"_last_fix_input.fixed.json\"\n        tmp_in.parent.mkdir(parents=True, exist_ok=True); tmp_in.write_text(raw, encoding=\"utf-8\")\n        fixer = self.tools_dir/\"fix_channel_a.py\"\n        if not fixer.exists(): messagebox.showerror(\"Quick Fix\", f\"Missing fixer: {fixer}\"); return\n        py = os.environ.get(\"PF_PY\") or shutil.which(\"py\") or shutil.which(\"python\") or \"python\"\n        cmd = [py, \"-3.12\", str(fixer), \"-i\", str(tmp_in), \"-o\", str(tmp_out), \"--report-json-only\"] if str(py).endswith(\"py\") else [py, str(fixer), \"-i\", str(tmp_in), \"-o\", str(tmp_out), \"--report-json-only\"]\n        proc = subprocess.run(cmd, capture_output=True, text=True, encoding=\"utf-8\", errors=\"replace\")\n        if proc.returncode not in (0,):\n            self._log(\"Quick Fix failed:\"); self._log(proc.stdout or \"\"); self._log(proc.stderr or \"\"); messagebox.showerror(\"Quick Fix\",\"Failed — see Errors panel\"); return\n        try: report = json.loads((proc.stdout or \"\").strip() or \"{}\")\n        except Exception: report = {\"status\":\"unknown\",\"messages\":[(proc.stdout or \"\").strip()]}\n        outp = report.get(\"output_path\", str(tmp_out))\n        if Path(outp).exists():\n            fixed = json.loads(Path(outp).read_text(encoding=\"utf-8\")); self.payload = fixed\n            self.txt_parsed.delete(\"1.0\",\"end\"); self.txt_parsed.insert(\"1.0\", json.dumps(fixed, indent=2, ensure_ascii=False))\n        changed = [m for m in report.get(\"messages\",[]) if any(k in m for k in (\"defaulted\",\"inferred\",\"filled\"))]\n        prose_msg = f\"Quick Fix: {report.get('status','unknown').upper()}. Wrote: {outp}\" + ((\"\\nChanges:\\n - \"+\"\\n - \".join(changed)) if changed else \"\")\n        self._prose(prose_msg); self._log(\"Quick Fix report: \"+json.dumps(report, ensure_ascii=False)); messagebox.showinfo(\"Quick Fix\", f\"Fixed payload written to:\\n{outp}\")\n\n    def ruff_fix(self) -> None:\n        payload = self._read_payload_from_editor(); \n        if not payload: return\n        ruff = shutil.which(\"ruff\")\n        if not ruff: messagebox.showerror(\"Ruff Fix\",\"ruff is not on PATH.\"); return\n        tmpdir = Path(tempfile.mkdtemp(prefix=\"pf_rufffix_\", dir=str(self.project_root/\".pf\") if (self.project_root/\".pf\").exists() else None))\n        changed = 0; details=[]\n        for idx,f in enumerate(payload.get(\"files\", [])):\n            lang = (f.get(\"language\") or \"\").lower(); src = f.get(\"contents\")\n            if lang not in (\"python\",\"py\") or src is None: continue\n            t = tmpdir/f\"snippet_{idx}.py\"; t.write_text(src, encoding=\"utf-8\")\n            subprocess.run([ruff, \"check\", \"--fix\", str(t)], capture_output=True, text=True, encoding=\"utf-8\", errors=\"replace\")\n            new_src = t.read_text(encoding=\"utf-8\")\n            if new_src != src:\n                payload[\"files\"][idx][\"contents\"] = new_src; changed += 1; details.append(f\"files[{idx}] fixed via ruff —> {t.name}\")\n        if changed:\n            self.payload = payload; self.txt_parsed.delete(\"1.0\",\"end\"); self.txt_parsed.insert(\"1.0\", json.dumps(payload, indent=2, ensure_ascii=False))\n            self._prose(f\"Ruff Fix: updated {changed} Python file(s) in payload.\");\n            if details: self._log(\"; \".join(details)); messagebox.showinfo(\"Ruff Fix\", f\"Updated {changed} Python file(s)\")\n        else:\n            messagebox.showinfo(\"Ruff Fix\", \"No Python files changed.\")\n\n    def fix_and_validate(self) -> None:\n        self.quick_fix(); self.ruff_fix(); payload = self._read_payload_from_editor(); \n        if not payload: return\n        res = gate_t2_validate(payload)\n        if res.get(\"pass\"): self._prose(\"Fix & Validate: PASS — ready to Apply.\"); messagebox.showinfo(\"Fix & Validate\",\"PASS\")\n        else:\n            self._log(\"Fix & Validate: Compliance FAIL\"); [self._log(e) for e in res.get(\"errors\",[])]; messagebox.showerror(\"Fix & Validate\",\"Compliance FAIL — see Errors panel\")\n\n    def do_apply(self) -> None:\n        payload = self._read_payload_from_editor(); \n        if not payload: return\n        s_errs = basic_schema_validate(payload)\n        if s_errs:\n            self._log(\"Apply blocked — schema invalid.\"); [self._log(\" - \"+e) for e in s_errs]; messagebox.showerror(\"Apply\",\"Blocked by Schema.\"); return\n        res = gate_t2_validate(payload)\n        if not res.get(\"pass\"):\n            self._log(\"Apply blocked — compliance failed.\"); [self._log(e) for e in res.get(\"errors\",[])];\n            if self.auto_retry: self._log(\"Tip: use Fix & Validate, then Retry.\")\n            messagebox.showerror(\"Apply\",\"Blocked by Compliance Gate.\"); return\n        files = payload.get(\"files\", [])\n        ops = prepare_ops_for_apply(self.project_root, files)\n        for f in files: apply_file(self.project_root, f)\n        jf = record_apply(self.project_root, ops); msg = f\"APPLY: PASS — JournalID: {jf.stem}\\nPath: {jf}\"\n        self._log(msg); self._prose(msg); messagebox.showinfo(\"Apply\", msg); self.payload = payload\n\n    def open_latest_journal(self) -> None:\n        jroot = self.project_root/\".pf\"/\"journal\"\n        if not jroot.exists(): messagebox.showwarning(\"Journal\",\"No .pf/journal found yet.\"); return\n        files = sorted(jroot.glob(\"*.jsonl\"))\n        if not files: messagebox.showwarning(\"Journal\",\"No journal entries yet.\"); return\n        latest = files[-1]; self._open_target(str(latest)); self._prose(f\"Opened latest journal: {latest}\")\n\n    def do_undo(self) -> None:\n        res = undo_last(self.project_root)\n        if res.get(\"ok\"): self._log(res[\"message\"]); messagebox.showinfo(\"Undo\", res[\"message\"]) \n        else: self._log(res.get(\"message\",\"Undo failed\")); messagebox.showwarning(\"Undo\", res.get(\"message\",\"Undo failed\"))\n\n    def do_retry(self) -> None:\n        if not self.payload: self._log(\"Nothing to retry.\"); return\n        res = gate_t2_validate(self.payload)\n        if res.get(\"pass\"): self._log(\"Retry: Compliance Gate now PASS\")\n        else: self._log(\"Retry: still FAIL\"); [self._log(e) for e in res.get(\"errors\",[])]\n\n    def run_scenario(self) -> None:\n        name = self.scenario_var.get().strip()\n        if not name: messagebox.showerror(\"Scenario\",\"No scenario selected.\"); return\n        script = self._scenario_script_for(name)\n        if not script.exists(): self._log(f\"Scenario script not found: {script}\"); messagebox.showerror(\"Scenario\", f\"Missing: {script.name}\"); return\n        try: result = run_pwsh_script(script, \"-ProjectRoot\", str(self.project_root))\n        except Exception as exc: self._log(f\"[{name}] ERROR — {exc}\"); messagebox.showerror(\"Scenario\", str(exc)); return\n        rc = getattr(result, \"returncode\", -1); out = getattr(result, \"stdout\", \"\") or \"\"; err = getattr(result, \"stderr\", \"\") or \"\"\n        if rc == 0:\n            self._log(f\"[{name}] OK\"); \n            if out.strip(): self._log(out.strip()); messagebox.showinfo(\"Scenario\", f\"{name}: OK\")\n        else:\n            self._log(f\"[{name}] FAIL ({rc})\"); \n            if out.strip(): self._log(out.strip()); \n            if err.strip(): self._log(err.strip()); messagebox.showerror(\"Scenario\", f\"{name}: FAIL — see Errors panel\")\n\n# PF_SENTINEL_END\n"
    },
    {
      "path": "v2/scripts/scenario_app_selfcheck.ps1",
      "language": "powershell",
      "op": "write",
      "contents": "[CmdletBinding()]\nparam([string]$ProjectRoot)\nSet-StrictMode -Version Latest\n$ErrorActionPreference='Stop'\nif ($ProjectRoot) { Set-Location -LiteralPath $ProjectRoot }\n$ok = $true\n$needPaths = @('.\\app.py', '.\\pf\\ui_app.py', '.\\pf\\utils.py', '.\\pf\\registry.py')\nforeach($p in $needPaths){ if(-not (Test-Path -LiteralPath $p)){ Write-Host \"Missing $p\"; $ok=$false } }\nif($ok){\n  $ui = Get-Content .\\pf\\ui_app.py -Raw\n  $need = @('Run Scenario','Validate Schema','Run Compliance','Quick Fix','Ruff Fix','Fix & Validate','Apply','Undo','Open Latest Journal','Retry','Project:','New…','PF_SENTINEL_END')\n  foreach($n in $need){ if($ui -notmatch [regex]::Escape($n)){ Write-Host \"Missing UI string: $n\"; $ok=$false } }\n}\nif($ok){ Write-Host 'Self-check: PASS'; exit 0 } else { Write-Host 'Self-check: FAIL'; exit 1 }\n"
    }
  ]
}
