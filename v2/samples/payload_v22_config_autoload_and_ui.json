{
  "files": [
    {
      "path": "app.py",
      "language": "python",
      "op": "write",
      "contents": "import hashlib\\nimport json\\nimport os\\nimport re\\nimport shutil\\nimport subprocess\\nimport tempfile\\nimport webbrowser\\nfrom pathlib import Path\\nimport tkinter as tk\\nfrom tkinter import filedialog, messagebox, ttk\\n\\nfrom pf.compliance_gate_t2 import validate as gate_t2_validate\\nfrom pf.change_journal import prepare_ops_for_apply, record_apply, undo_last\\n\\nPROJECT_ROOT = Path.cwd()\\nSCRIPTS_DIR = PROJECT_ROOT / \\"v2\\" / \\"scripts\\"\\nTOOLS_DIR = PROJECT_ROOT / \\"v2\\" / \\"tools\\"\\nCFG_PATH = PROJECT_ROOT / \\".pf\\" / \\"project.json\\"\\n\\n# Friendly matchers (keep simple and robust)\\nURL_RE = re.compile(r\\\"(https?://\\\\S+)\\\")\\nPATH_RE = re.compile(r\\\"([A-Za-z]:[\\\\/][^\\\\s\\\\r\\\\n]+\\\\.(?:json|py|ps1|md|txt)|/[^\\\\s\\\\r\\\\n]+\\\\.(?:json|py|ps1|md|txt))\\\")\\n\\n\\n# ---------- Config ----------\\ndef load_project_config(root: Path) -> dict:\\n    \\\\\"Read .pf/project.json if present, else defaults.\\\\\"\\n    try:\\n        if CFG_PATH.exists():\\n            return json.loads(CFG_PATH.read_text(encoding=\\\"utf-8\\\"))\\n    except Exception as exc:\\n        print(f\\\"Config read error: {exc}\\\")\\n    return {\\n        \\\"version\\\": \\\"2.2\\\",\\n        \\\"retry_policy\\\": {\\\"auto_retries\\\": 1, \\\"manual_retry\\\": True},\\n        \\\"undo\\\": {\\\"mode\\\": \\\"history\\\"},\\n        \\\"scenarios\\\": {\\n            \\\"system\\\": [\\n                \\\"setup_run_ui\\\",\\n                \\\"venv_validate\\\",\\n                \\\"standard_test_and_lint\\\",\\n                \\\"tool_commands\\\",\\n                \\\"standard_git_publish\\\"\\n            ]\\n        }\\n    }\\n\\n\\ndef scenario_script_for(name: str) -> Path:\\n    \\\\\"Resolve a scenario name to its script path by convention.\\\\\"\\n    return SCRIPTS_DIR / f\\\"scenario_{name}.ps1\\\"\\n\\n\\n# ---------- Subprocess helpers ----------\\ndef _run_pwsh_script(script_path: Path, *args):\\n    # Force UTF-8 decode and never crash on odd bytes\\n    cmd = [\\\"pwsh\\\", \\\"-NoProfile\\\", \\\"-File\\\", str(script_path), *args]\\n    return subprocess.run(\\n        cmd,\\n        capture_output=True,\\n        text=True,\\n        encoding=\\\"utf-8\\\",\\n        errors=\\\"replace\\\"\\n    )\\n\\n\\ndef _apply_file(project_root: Path, f: dict):\\n    op = (f.get(\\\"op\\\") or \\\"write\\\").lower()\\n    path = project_root / f[\\\"path\\\"]\\n    path.parent.mkdir(parents=True, exist_ok=True)\\n    if op == \\\"write\\\":\\n        path.write_text(f.get(\\\"contents\\\") or \\\"\\\", encoding=\\\"utf-8\\\")\\n    elif op == \\\"patch\\\":\\n        if path.exists():\\n            existing = path.read_text(encoding=\\\"utf-8\\\")\\n            patch = f.get(\\\"contents\\\") or \\\"\\\"\\n            if patch not in existing:\\n                path.write_text(existing + \\\"\\\\n\\\" + patch, encoding=\\\"utf-8\\\")\\n        else:\\n            path.write_text(f.get(\\\"contents\\\") or \\\"\\\", encoding=\\\"utf-8\\\")\\n    elif op == \\\"delete\\\":\\n        if path.exists():\\n            path.unlink()\\n    elif op == \\\"rename\\\":\\n        src = f.get(\\\"from\\\")\\n        dst = f.get(\\\"to\\\")\\n        if src and dst:\\n            (project_root / dst).parent.mkdir(parents=True, exist_ok=True)\\n            (project_root / src).replace(project_root / dst)\\n\\n\\ndef _basic_schema_validate(payload: dict) -> list[str]:\\n    errs: list[str] = []\\n    if not isinstance(payload, dict):\\n        return [\\\"Payload must be a JSON object.\\\"]\\n    files = payload.get(\\\"files\\\")\\n    if not isinstance(files, list) or not files:\\n        errs.append(\\\"Payload.files must be a non-empty list.\\\")\\n        return errs\\n    for i, f in enumerate(files):\\n        if not isinstance(f, dict):\\n            errs.append(f\\\"files[{i}] must be an object.\\\")\\n            continue\\n        for req in (\\\"path\\\", \\\"op\\\", \\\"language\\\"):\\n            if not f.get(req):\\n                errs.append(f\\\"files[{i}].{req} is required.\\\")\\n        if f.get(\\\"op\\\") not in (\\\"write\\\", \\\"patch\\\", \\\"delete\\\", \\\"rename\\\"):\\n            errs.append(\\\"files[%d].op must be write|patch|delete|rename.\\\" % i)\\n        if f.get(\\\"op\\\") in (\\\"write\\\", \\\"patch\\\") and \\\"contents\\\" not in f:\\n            errs.append(\\\"files[%d].contents is required for op=%s.\\\" % (i, f.get(\\\"op\\\")))\\n        if f.get(\\\"op\\\") == \\\"rename\\\" and (not f.get(\\\"from\\\") or not f.get(\\\"to\\\")):\\n            errs.append(\\\"files[%d].from and .to required for op=rename.\\\" % i)\\n    return errs\\n\\n\\nclass App(tk.Tk):\\n    def __init__(self) -> None:\\n        super().__init__()\\n        self.title(\\\"PromptForge — V2.2 Test Rig\\\")\\n        self.geometry(\\\"1280x900\\\")\\n        self.payload: dict | None = None\\n        self.payload_id: str | None = None\\n        self.config_data = load_project_config(PROJECT_ROOT)\\n        self.auto_retry = bool(self.config_data.get(\\\"retry_policy\\\", {}).get(\\\"auto_retries\\\", 1))\\n\\n        toolbar = tk.Frame(self)\\n        toolbar.pack(fill=\\\"x\\\", padx=8, pady=6)\\n        tk.Button(toolbar, text=\\\"Load JSON\\\", command=self.load_json).pack(side=\\\"left\\\")\\n        tk.Button(toolbar, text=\\\"Save JSON\\\", command=self.save_json).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Validate Schema\\\", command=self.validate_schema).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Run Compliance\\\", command=self.run_gate).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Quick Fix\\\", command=self.quick_fix).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Ruff Fix\\\", command=self.ruff_fix).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Fix & Validate\\\", command=self.fix_and_validate).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Apply\\\", command=self.do_apply).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Undo\\\", command=self.do_undo).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Open Latest Journal\\\", command=self.open_latest_journal).pack(side=\\\"left\\\", padx=6)\\n        tk.Button(toolbar, text=\\\"Retry\\\", command=self.do_retry).pack(side=\\\"left\\\", padx=6)\\n\\n        tk.Label(toolbar, text=\\\"Scenario:\\\").pack(side=\\\"left\\\", padx=(24, 4))\\n        self.scenario_var = tk.StringVar(value=\\\"\\\")\\n        self.scenario_combo = ttk.Combobox(toolbar, textvariable=self.scenario_var, width=28)\\n        self.refresh_scenarios()\\n        self.scenario_combo.pack(side=\\\"left\\\")\\n        tk.Button(toolbar, text=\\\"Run Scenario\\\", command=self.run_scenario).pack(side=\\\"left\\\", padx=6)\\n\\n        paned = tk.PanedWindow(self, sashrelief=\\\"raised\\\", orient=\\\"horizontal\\\")\\n        paned.pack(expand=True, fill=\\\"both\\\")\\n        left = tk.PanedWindow(paned, orient=\\\"vertical\\\")\\n        right = tk.PanedWindow(paned, orient=\\\"vertical\\\")\\n        paned.add(left)\\n        paned.add(right)\\n\\n        self.txt_parsed = self._panel(left, \\\"Parsed A (Channel-A JSON)\\\")\\n        self.txt_prose = self._panel(left, \\\"Prose B (human narrative)\\\")\\n        self.txt_errors = self._panel(right, \\\"Errors / Logs\\\")\\n        self._attach_context_menu(self.txt_parsed)\\n        self._attach_context_menu(self.txt_prose)\\n        self._attach_context_menu(self.txt_errors)\\n\\n        self._log(\\\"Project root: \\\" + str(PROJECT_ROOT))\\n        self._prose(\\\"Config loaded from .pf/project.json (if present). Auto-retry: \\\" + (\\\"on\\\" if self.auto_retry else \\\"off\\\"))\\n\\n    # ---- UI helpers ----\\n    def _panel(self, parent, title: str) -> tk.Text:\\n        frame = tk.Frame(parent)\\n        parent.add(frame)\\n        tk.Label(frame, text=title, anchor=\\\"w\\\").pack(fill=\\\"x\\\")\\n        text = tk.Text(frame, wrap=\\\"word\\\", undo=True)\\n        text.pack(expand=True, fill=\\\"both\\\")\\n        return text\\n\\n    def _attach_context_menu(self, widget: tk.Text) -> None:\\n        menu = tk.Menu(widget, tearoff=0)\\n        menu.add_command(label=\\\"Copy\\\", command=lambda w=widget: w.event_generate(\\\"<<Copy>>\\\"))\\n        menu.add_command(label=\\\"Paste\\\", command=lambda w=widget: w.event_generate(\\\"<<Paste>>\\\"))\\n        menu.add_command(label=\\\"Cut\\\", command=lambda w=widget: w.event_generate(\\\"<<Cut>>\\\"))\\n        menu.add_separator()\\n        menu.add_command(label=\\\"Select All\\\", command=lambda w=widget: w.tag_add(\\\"sel\\\", \\\"1.0\\\", \\\"end-1c\\\"))\\n        menu.add_command(label=\\\"Open Selection\\\", command=lambda w=widget: self._open_selection(w))\\n        def show_menu(evt):\\n            try:\\n                menu.tk_popup(evt.x_root, evt.y_root)\\n            finally:\\n                menu.grab_release()\\n        widget.bind(\\\"<Button-3>\\\", show_menu)\\n        widget.bind(\\\"<Control-Button-1>\\\", show_menu)  # mac ctrl-click\\n\\n    def _open_selection(self, widget: tk.Text) -> None:\\n        try:\\n            sel = widget.get(\\\"sel.first\\\", \\\"sel.last\\\").strip()\\n        except tk.TclError:\\n            sel = \\\"\\\"\\n        if sel:\\n            self._open_target(sel)\\n\\n    def _linkify(self, widget: tk.Text) -> None:\\n        content = widget.get(\\\"1.0\\\", \\\"end\\\")\\n        for match in URL_RE.finditer(content):\\n            self._tag_link(widget, match.start(), match.end(), match.group(1))\\n        for match in PATH_RE.finditer(content):\\n            self._tag_link(widget, match.start(1), match.end(1), match.group(1))\\n\\n    def _tag_link(self, widget: tk.Text, start: int, end: int, target: str) -> None:\\n        s = self._idx_to_text_index(widget, start)\\n        e = self._idx_to_text_index(widget, end)\\n        tag = f\\\"link_{start}_{end}\\\"\\n        widget.tag_add(tag, s, e)\\n        widget.tag_config(tag, foreground=\\\"blue\\\", underline=True)\\n        widget.tag_bind(tag, \\\"<Enter>\\\", lambda _e: widget.config(cursor=\\\"hand2\\\"))\\n        widget.tag_bind(tag, \\\"<Leave>\\\", lambda _e: widget.config(cursor=\\\"\\\"))\\n        widget.tag_bind(tag, \\\"<Button-1>\\\", lambda _e, t=target: self._open_target(t))\\n\\n    def _idx_to_text_index(self, widget: tk.Text, n: int) -> str:\\n        content = widget.get(\\\"1.0\\\", \\\"end\\\")\\n        before = content[:n]\\n        line = before.count(\\\"\\\\n\\\") + 1\\n        col = len(before.rsplit(\\\"\\\\n\\\", 1)[-1]) + 1\\n        return f\\\"{line}.{col}\\\"\\n\\n    def _open_target(self, target: str) -> None:\\n        val = target.strip()\\n        if val.startswith(\\\"http://\\\") or val.startswith(\\\"https://\\\"):\\n            webbrowser.open(val)\\n            return\\n        path = Path(val)\\n        editor = os.environ.get(\\\"PF_EDITOR_CMD\\\")\\n        if editor:\\n            cmd = editor.format(path=str(path)) if \\\"{path}\\\" in editor else f\\\"{editor} {path}\\\"\\n            subprocess.Popen(cmd, shell=True)\\n            return\\n        if shutil.which(\\\"code\\\"):\\n            subprocess.Popen([\\\"code\\\", \\\"-g\\\", str(path)])\\n        elif os.name == \\\"nt\\\":\\n            os.startfile(str(path))  # type: ignore[attr-defined]\\n        else:\\n            subprocess.Popen([\\\"xdg-open\\\", str(path)])\\n\\n    def _log(self, msg: str) -> None:\\n        self.txt_errors.insert(\\\"end\\\", msg + \\\"\\\\n\\\")\\n        self.txt_errors.see(\\\"end\\\")\\n        self._linkify(self.txt_errors)\\n\\n    def _prose(self, msg: str) -> None:\\n        self.txt_prose.insert(\\\"end\\\", msg + \\\"\\\\n\\\")\\n        self.txt_prose.see(\\\"end\\\")\\n        self._linkify(self.txt_prose)\\n\\n    # ---- Config-driven scenarios ----\\n    def refresh_scenarios(self) -> None:\\n        sys_list = list(self.config_data.get(\\\"scenarios\\\", {}).get(\\\"system\\\", []))\\n        proj_list = list(self.config_data.get(\\\"scenarios\\\", {}).get(\\\"project\\\", []))\\n        names = sys_list + [n for n in proj_list if n not in sys_list]\\n        if not names:\\n            names = [\\\"setup_run_ui\\\", \\\"venv_validate\\\", \\\"standard_test_and_lint\\\", \\\"tool_commands\\\", \\\"standard_git_publish\\\"]\\n        self.scenario_combo[\\\"values\\\"] = names\\n        self.scenario_var.set(names[0])\\n\\n    # ---- Core actions ----\\n    def load_json(self) -> None:\\n        path = filedialog.askopenfilename(title=\\\"Select Channel-A JSON\\\", filetypes=[(\\\"JSON files\\\", \\\"*.json\\\"), (\\\"All files\\\", \\\"*.*\\\")])\\n        if not path:\\n            return\\n        with open(path, \\\"r\\\", encoding=\\\"utf-8\\\") as handle:\\n            self.payload = json.load(handle)\\n        self.txt_parsed.delete(\\\"1.0\\\", \\\"end\\\")\\n        self.txt_parsed.insert(\\\"1.0\\\", json.dumps(self.payload, indent=2, ensure_ascii=False))\\n        self._log(f\\\"Loaded payload: {path}\\\")\\n\\n    def save_json(self) -> None:\\n        if not self.payload:\\n            try:\\n                self.payload = json.loads(self.txt_parsed.get(\\\"1.0\\\", \\\"end\\\").strip())\\n            except Exception as exc:\\n                messagebox.showerror(\\\"Save JSON\\\", f\\\"No valid JSON loaded/typed.\\\\n{exc}\\\")\\n                return\\n        dest = filedialog.asksaveasfilename(defaultextension=\\\".json\\\", filetypes=[(\\\"JSON\\\", \\\"*.json\\\")])\\n        if not dest:\\n            return\\n        with open(dest, \\\"w\\\", encoding=\\\"utf-8\\\") as handle:\\n            json.dump(self.payload, handle, indent=2, ensure_ascii=False)\\n        self._log(f\\\"Saved payload: {dest}\\\")\\n\\n    def _read_payload_from_editor(self) -> dict | None:\\n        try:\\n            return json.loads(self.txt_parsed.get(\\\"1.0\\\", \\\"end\\\").strip())\\n        except Exception as exc:\\n            messagebox.showerror(\\\"Invalid JSON\\\", str(exc))\\n            return None\\n\\n    def _compute_payload_id(self, payload: dict) -> str:\\n        norm = json.dumps(payload, sort_keys=True, ensure_ascii=False)\\n        return hashlib.sha256(norm.encode(\\\"utf-8\\\")).hexdigest()[:8]\\n\\n    def validate_schema(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        errs = _basic_schema_validate(payload)\\n        if errs:\\n            self._log(\\\"SCHEMA: FAIL\\\")\\n            for e in errs:\\n                self._log(\\\" - \\\" + e)\\n            messagebox.showerror(\\\"Schema\\\", \\\"FAIL — see Errors panel\\\")\\n        else:\\n            self.payload_id = self._compute_payload_id(payload)\\n            msg = f\\\"SCHEMA: PASS — PayloadID: {self.payload_id}\\\"\\n            self._log(msg)\\n            self._prose(msg)\\n            messagebox.showinfo(\\\"Schema\\\", msg)\\n        self.payload = payload\\n\\n    def run_gate(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        res = gate_t2_validate(payload)\\n        if res.get(\\\"pass\\"):\\n            self._log(\\\"Compliance Gate: PASS\\\")\\n            messagebox.showinfo(\\\"Compliance\\\", \\\"PASS\\\")\\n        else:\\n            self._log(\\\"Compliance Gate: FAIL\\\")\\n            for e in res.get(\\\"errors\\\", []):\\n                self._log(e)\\n            messagebox.showerror(\\\"Compliance\\\", \\\"FAIL — see Errors panel\\\")\\n        self.payload = payload\\n\\n    def quick_fix(self) -> None:\\n        raw = self.txt_parsed.get(\\\"1.0\\\", \\\"end\\\").strip()\\n        if not raw:\\n            messagebox.showerror(\\\"Quick Fix\\\", \\\"No JSON in Parsed panel.\\\")\\n            return\\n        try:\\n            json.loads(raw)\\n        except Exception:\\n            messagebox.showerror(\\\"Quick Fix\\\", \\\"Invalid JSON in Parsed panel.\\\")\\n            return\\n        tmp_in = PROJECT_ROOT / \\\"v2\\\" / \\\"samples\\\" / \\\"_last_fix_input.json\\\"\\n        tmp_out = PROJECT_ROOT / \\\"v2\\\" / \\\"samples\\\" / \\\"_last_fix_input.fixed.json\\\"\\n        tmp_in.parent.mkdir(parents=True, exist_ok=True)\\n        tmp_in.write_text(raw, encoding=\\\"utf-8\\\")\\n\\n        fixer = TOOLS_DIR / \\\"fix_channel_a.py\\\"\\n        if not fixer.exists():\\n            messagebox.showerror(\\\"Quick Fix\\\", f\\\"Missing fixer: {fixer}\\\")\\n            return\\n\\n        py_exe = os.environ.get(\\\"PF_PY\\\") or shutil.which(\\\"py\\\") or shutil.which(\\\"python\\\") or \\\"python\\\"\\n        if str(py_exe).endswith(\\\"py\\\") or str(py_exe).endswith(\\\"py.exe\\\"):\\n            cmd = [py_exe, \\\"-3.12\\\", str(fixer), \\\"-i\\\", str(tmp_in), \\\"-o\\\", str(tmp_out), \\\"--report-json-only\\\"]\\n        else:\\n            cmd = [py_exe, str(fixer), \\\"-i\\\", str(tmp_in), \\\"-o\\\", str(tmp_out), \\\"--report-json-only\\\"]\\n        proc = subprocess.run(cmd, capture_output=True, text=True, encoding=\\\"utf-8\\\", errors=\\\"replace\\\")\\n        if proc.returncode not in (0,):\\n            self._log(\\\"Quick Fix failed:\\\")\\n            self._log(proc.stdout or \\\"\\\")\\n            self._log(proc.stderr or \\\"\\\")\\n            messagebox.showerror(\\\"Quick Fix\\\", \\\"Failed — see Errors panel\\\")\\n            return\\n        try:\\n            report = json.loads((proc.stdout or \\\"\\\").strip() or \\\"{}\\\")\\n        except Exception:\\n            report = {\\\"status\\\": \\\"unknown\\\", \\\"messages\\\": [(proc.stdout or \\\"\\\").strip()]}\\n\\n        status = report.get(\\\"status\\\", \\\"unknown\\\")\\n        outp = report.get(\\\"output_path\\\", str(tmp_out))\\n        msgs = report.get(\\\"messages\\\", [])\\n\\n        if Path(outp).exists():\\n            fixed = json.loads(Path(outp).read_text(encoding=\\\"utf-8\\\"))\\n            self.payload = fixed\\n            self.txt_parsed.delete(\\\"1.0\\\", \\\"end\\\")\\n            self.txt_parsed.insert(\\\"1.0\\\", json.dumps(fixed, indent=2, ensure_ascii=False))\\n\\n        changed = [m for m in msgs if (\\\"defaulted\\\" in m or \\\"inferred\\\" in m or \\\"filled\\\" in m)]\\n        prose_msg = f\\\"Quick Fix: {status.upper()}. Wrote: {outp}\\\"\\n        if changed:\\n            prose_msg += \\\"\\\\nChanges:\\\\n - \\\" + \\\"\\\\n - \\\".join(changed)\\n        self._prose(prose_msg)\\n        self._log(\\\"Quick Fix report: \\\" + json.dumps(report, ensure_ascii=False))\\n        messagebox.showinfo(\\\"Quick Fix\\\", f\\\"Fixed payload written to:\\\\n{outp}\\\")\\n\\n    def ruff_fix(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        ruff = shutil.which(\\\"ruff\\\")\\n        if not ruff:\\n            messagebox.showerror(\\\"Ruff Fix\\\", \\\"ruff is not on PATH.\\\")\\n            return\\n        tmpdir = Path(tempfile.mkdtemp(prefix=\\\"pf_rufffix_\\\", dir=str(PROJECT_ROOT / \\\".pf\\\") if (PROJECT_ROOT / \\\".pf\\\").exists() else None))\\n        changed_count = 0\\n        details: list[str] = []\\n        for idx, f in enumerate(payload.get(\\\"files\\\", [])):\\n            lang = (f.get(\\\"language\\\") or \\\"\\\").lower()\\n            src = f.get(\\\"contents\\\")\\n            if lang not in (\\\"python\\\", \\\"py\\\") or src is None:\\n                continue\\n            tpath = tmpdir / f\\\"snippet_{idx}.py\\\"\\n            tpath.write_text(src, encoding=\\\"utf-8\\\")\\n            subprocess.run([ruff, \\\"check\\\", \\\"--fix\\\", str(tpath)], capture_output=True, text=True, encoding=\\\"utf-8\\\", errors=\\\"replace\\\")\\n            new_src = tpath.read_text(encoding=\\\"utf-8\\\")\\n            if new_src != src:\\n                payload[\\\"files\\\"][idx][\\\"contents\\\"] = new_src\\n                changed_count += 1\\n                details.append(f\\\"files[{idx}] fixed via ruff --fix -> {tpath.name}\\\")\\n        if changed_count:\\n            self.payload = payload\\n            self.txt_parsed.delete(\\\"1.0\\\", \\\"end\\\")\\n            self.txt_parsed.insert(\\\"1.0\\\", json.dumps(payload, indent=2, ensure_ascii=False))\\n            msg = f\\\"Ruff Fix: updated {changed_count} Python file(s) in payload.\\\"\\n            self._prose(msg)\\n            if details:\\n                self._log(\\\"; \\\".join(details))\\n            messagebox.showinfo(\\\"Ruff Fix\\\", msg)\\n        else:\\n            messagebox.showinfo(\\\"Ruff Fix\\\", \\\"No Python files changed.\\\")\\n\\n    def fix_and_validate(self) -> None:\\n        self.quick_fix()\\n        self.ruff_fix()\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        res = gate_t2_validate(payload)\\n        if res.get(\\\"pass\\\"):\\n            msg = \\\"Fix & Validate: PASS — ready to Apply.\\\"\\n            self._prose(msg)\\n            messagebox.showinfo(\\\"Fix & Validate\\\", msg)\\n        else:\\n            self._log(\\\"Fix & Validate: Compliance FAIL\\\")\\n            for e in res.get(\\\"errors\\\", []):\\n                self._log(e)\\n            messagebox.showerror(\\\"Fix & Validate\\\", \\\"Compliance FAIL — see Errors panel\\\")\\n\\n    def do_apply(self) -> None:\\n        payload = self._read_payload_from_editor()\\n        if not payload:\\n            return\\n        s_errs = _basic_schema_validate(payload)\\n        if s_errs:\\n            self._log(\\\"Apply blocked — schema invalid.\\\")\\n            for e in s_errs:\\n                self._log(\\\" - \\\" + e)\\n            messagebox.showerror(\\\"Apply\\\", \\\"Blocked by Schema.\\\")\\n            return\\n        res = gate_t2_validate(payload)\\n        if not res.get(\\\"pass\\\"):\\n            self._log(\\\"Apply blocked — compliance failed.\\\")\\n            for e in res.get(\\\"errors\\\", []):\\n                self._log(e)\\n            if self.auto_retry:\\n                self._log(\\\"Tip: use Fix & Validate, then Retry.\\\")\\n            messagebox.showerror(\\\"Apply\\\", \\\"Blocked by Compliance Gate.\\\")\\n            return\\n        files = payload.get(\\\"files\\\", [])\\n        ops = prepare_ops_for_apply(PROJECT_ROOT, files)\\n        for f in files:\\n            _apply_file(PROJECT_ROOT, f)\\n        jf = record_apply(PROJECT_ROOT, ops)\\n        journal_id = jf.stem\\n        msg = f\\\"APPLY: PASS — JournalID: {journal_id}\\\\nPath: {jf}\\\"\\n        self._log(msg)\\n        self._prose(msg)\\n        messagebox.showinfo(\\\"Apply\\\", msg)\\n        self.payload = payload\\n\\n    def open_latest_journal(self) -> None:\\n        jroot = PROJECT_ROOT / \\\".pf\\\" / \\\"journal\\\"\\n        if not jroot.exists():\\n            messagebox.showwarning(\\\"Journal\\\", \\\"No .pf/journal found yet.\\\")\\n            return\\n        files = sorted(jroot.glob(\\\"*.jsonl\\\"))\\n        if not files:\\n            messagebox.showwarning(\\\"Journal\\\", \\\"No journal entries yet.\\\")\\n            return\\n        latest = files[-1]\\n        self._open_target(str(latest))\\n        self._prose(f\\\"Opened latest journal: {latest}\\\")\\n\\n    def do_undo(self) -> None:\\n        res = undo_last(PROJECT_ROOT)\\n        if res.get(\\\"ok\\"):\\n            self._log(res[\\\"message\\\"])\\n            messagebox.showinfo(\\\"Undo\\\", res[\\\"message\\\"])\\n        else:\\n            self._log(res.get(\\\"message\\\", \\\"Undo failed\\\"))\\n            messagebox.showwarning(\\\"Undo\\\", res.get(\\\"message\\\", \\\"Undo failed\\\"))\\n\\n    def do_retry(self) -> None:\\n        if not self.payload:\\n            self._log(\\\"Nothing to retry.\\\")\\n            return\\n        res = gate_t2_validate(self.payload)\\n        if res.get(\\\"pass\\\"):\\n            self._log(\\\"Retry: Compliance Gate now PASS\\\")\\n        else:\\n            self._log(\\\"Retry: still FAIL\\\")\\n            for e in res.get(\\\"errors\\\", []):\\n                self._log(e)\\n\\n    def run_scenario(self) -> None:\\n        name = self.scenario_var.get().strip()\\n        if not name:\\n            messagebox.showerror(\\\"Scenario\\\", \\\"No scenario selected.\\\")\\n            return\\n        script = scenario_script_for(name)\\n        if not script.exists():\\n            self._log(f\\\"Scenario script not found: {script}\\\")\\n            messagebox.showerror(\\\"Scenario\\\", f\\\"Missing: {script.name}\\\")\\n            return\\n        try:\\n            result = _run_pwsh_script(script, \\\"-ProjectRoot\\\", str(PROJECT_ROOT))\\n        except Exception as exc:\\n            self._log(f\\\"[{name}] ERROR — {exc}\\\")\\n            messagebox.showerror(\\\"Scenario\\\", str(exc))\\n            return\\n        rc = getattr(result, \\\"returncode\\\", -1)\\n        out = getattr(result, \\\"stdout\\\", \\\"\\\") or \\\"\\\"\\n        err = getattr(result, \\\"stderr\\\", \\\"\\\") or \\\"\\\"\\n        if rc == 0:\\n            self._log(f\\\"[{name}] OK\\\")\\n            if out.strip():\\n                self._log(out.strip())\\n            messagebox.showinfo(\\\"Scenario\\\", f\\\"{name}: OK\\\")\\n        else:\\n            self._log(f\\\"[{name}] FAIL ({rc})\\\")\\n            if out.strip():\\n                self._log(out.strip())\\n            if err.strip():\\n                self._log(err.strip())\\n            messagebox.showerror(\\\"Scenario\\\", f\\\"{name}: FAIL — see Errors panel\\\")\\n\\n\\nif __name__ == \\\"__main__\\\":\\n    App().mainloop()\\n"
    },
    {
      "path": "v2/scripts/scenario_setup_run_ui.ps1",
      "language": "powershell",
      "op": "write",
      "contents": "[CmdletBinding()]\nparam([string]$ProjectRoot)\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n# Force UTF-8 output to match Python's decoder\n$OutputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new($false)\nif ($ProjectRoot) { Set-Location -LiteralPath $ProjectRoot }\n$py = $env:PF_PY\nif (-not $py) { $py = (Get-Command py -ErrorAction SilentlyContinue)?.Source }\nif (-not $py) { $py = (Get-Command python -ErrorAction SilentlyContinue)?.Source }\nif (-not $py) { throw 'Python not found. Set PF_PY or install Python 3.12+' }\nWrite-Host \"Launching: $py app.py\"\n& $py -3.12 .\\app.py 2>$null\nif ($LASTEXITCODE -ne 0) { & $py .\\app.py }\nWrite-Host \"GUI exit code: $LASTEXITCODE\"\nexit 0\n"
    },
    {
      "path": "v2/scripts/scenario_venv_validate.ps1",
      "language": "powershell",
      "op": "write",
      "contents": "[CmdletBinding()]\nparam([string]$ProjectRoot)\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n$OutputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new($false)\nif ($ProjectRoot) { Set-Location -LiteralPath $ProjectRoot }\n$errors = @()\n\n# Python\n$pyver = & py -3.12 -c \"import sys;print(sys.version.split()[0])\" 2>$null\nif (-not $pyver) { $errors += 'Python 3.12 not found (py -3.12).'; } else { Write-Host \"Python: $pyver\" }\n\n# ruff\n$ruff = Get-Command ruff -ErrorAction SilentlyContinue\nif (-not $ruff) { $errors += 'ruff not on PATH. Try: py -3.12 -m pip install -U ruff' } else { Write-Host (ruff --version 2>$null) }\n\n# PSScriptAnalyzer\n$isa = Get-Command Invoke-ScriptAnalyzer -ErrorAction SilentlyContinue\nif (-not $isa) { $errors += 'PSScriptAnalyzer missing. Install: Install-Module PSScriptAnalyzer -Scope CurrentUser -Force' } else { Write-Host 'PSScriptAnalyzer: OK' }\n\n# pytest (optional)\n$pytest = & py -3.12 -m pytest --version 2>$null\nif (-not $pytest) { Write-Host 'pytest not found (optional).' } else { Write-Host $pytest }\n\nif ($errors.Count) {\n  Write-Host 'Validation: FAIL' -ForegroundColor Red\n  $errors | ForEach-Object { Write-Host \" - $_\" -ForegroundColor Red }\n  exit 1\n}\nWrite-Host 'Validation: PASS' -ForegroundColor Green\nexit 0\n"
    },
    {
      "path": "v2/scripts/scenario_tool_commands.ps1",
      "language": "powershell",
      "op": "write",
      "contents": "[CmdletBinding()]\nparam([string]$ProjectRoot)\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n$OutputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new($false)\nif ($ProjectRoot) { Set-Location -LiteralPath $ProjectRoot }\n$py = (Get-Command py -ErrorAction SilentlyContinue)?.Source\nif (-not $py) { $py = (Get-Command python -ErrorAction SilentlyContinue)?.Source }\nWrite-Host 'fix_channel_a.py --help'\n& $py -3.12 v2/tools/fix_channel_a.py -h 2>&1 | Write-Output\nexit $LASTEXITCODE\n"
    },
    {
      "path": "v2/scripts/scenario_test_and_lint.ps1",
      "language": "powershell",
      "op": "write",
      "contents": "[CmdletBinding()]\nparam([string]$ProjectRoot)\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n$OutputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new($false)\nif ($ProjectRoot) { Set-Location -LiteralPath $ProjectRoot }\n$failed = $false\n\nif (Get-Command ruff -ErrorAction SilentlyContinue) {\n  Write-Host 'Running ruff check ...'\n  ruff check . | Write-Output\n  if ($LASTEXITCODE -ne 0) { $failed = $true }\n} else { Write-Host 'ruff not found; skipping' }\n\n$hasTests = Test-Path -LiteralPath '.\\tests'\nif ($hasTests) {\n  Write-Host 'Running pytest -q ...'\n  py -3.12 -m pytest -q\n  if ($LASTEXITCODE -ne 0) { $failed = $true }\n} else { Write-Host 'No tests/ folder; skipping pytest' }\n\nif ($failed) { exit 1 } else { exit 0 }\n"
    },
    {
      "path": "v2/scripts/scenario_git_publish.ps1",
      "language": "powershell",
      "op": "write",
      "contents": "[CmdletBinding()]\nparam([string]$ProjectRoot)\nSet-StrictMode -Version Latest\n$ErrorActionPreference = 'Stop'\n$OutputEncoding = [Console]::OutputEncoding = [System.Text.UTF8Encoding]::new($false)\nif ($ProjectRoot) { Set-Location -LiteralPath $ProjectRoot }\nif (-not (Get-Command git -ErrorAction SilentlyContinue)) { Write-Host 'git not found'; exit 1 }\nWrite-Host 'Git status:'\ngit status --porcelain=v1 -b\nWrite-Host ''\nWrite-Host 'Dry-run. To publish:'\nWrite-Host '  git add -A'\nWrite-Host '  git commit -m \"pf: apply changes\"'\nWrite-Host '  git push'\nexit 0\n"
    }
  ]
}
