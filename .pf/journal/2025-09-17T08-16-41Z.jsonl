{"op": "write", "path": "G:\\My Drive\\Code\\Python\\PromptForge\\v2\\tools\\fix_channel_a.py", "before_sha": "3530c608894aeead5667599d8200019a7882610a9796bdcafb1e34096d63f378", "after_sha": "d8463d20133e490d4c45842fb7fbc768106903200922ebb2ae014e87efc28cc7", "before_bytes": "import argparse\r\nimport json\r\nimport sys\r\nfrom pathlib import Path\r\n\r\nEXT_TO_LANG = {\r\n    \".py\": \"python\",\r\n    \".ps1\": \"powershell\",\r\n    \".json\": \"json\",\r\n    \".psm1\": \"powershell\",\r\n    \".psd1\": \"powershell\",\r\n    \".cmd\": \"batch\",\r\n    \".bat\": \"batch\",\r\n    \".yml\": \"yaml\",\r\n    \".yaml\": \"yaml\",\r\n    \".toml\": \"toml\",\r\n    \".md\": \"markdown\",\r\n    \".txt\": \"text\"\r\n}\r\n\r\nLANG_STUB = {\r\n    \"python\": \"pass\\n\",\r\n    \"powershell\": \"#\\n\",\r\n    \"json\": \"{}\\n\",\r\n    \"yaml\": \"#\\n\",\r\n    \"toml\": \"#\\n\",\r\n    \"markdown\": \"\\n\",\r\n    \"text\": \"\\n\",\r\n    \"batch\": \"REM\\n\"\r\n}\r\n\r\ndef infer_language_from_path(path: str) -> str | None:\r\n    return EXT_TO_LANG.get(Path(path).suffix.lower())\r\n\r\ndef stub_for_language(lang: str) -> str:\r\n    return LANG_STUB.get(lang, \"\\n\")\r\n\r\ndef fix_payload(payload: dict, fill_stubs: bool = True):\r\n    changes: list[str] = []\r\n    errors: list[str] = []\r\n\r\n    if not isinstance(payload, dict):\r\n        return None, [\"Payload must be a JSON object\"]\r\n\r\n    files = payload.get(\"files\")\r\n    if not isinstance(files, list):\r\n        return None, [\"Payload.files must be a list\"]\r\n\r\n    for i, f in enumerate(files):\r\n        if not isinstance(f, dict):\r\n            errors.append(f\"files[{i}] is not an object\")\r\n            continue\r\n\r\n        path = f.get(\"path\")\r\n        if not path:\r\n            errors.append(f\"files[{i}].path missing\")\r\n            continue\r\n\r\n        op = f.get(\"op\")\r\n        if not op:\r\n            f[\"op\"] = \"write\"\r\n            op = \"write\"\r\n            changes.append(f\"files[{i}].op defaulted to 'write'\")\r\n\r\n        lang = (f.get(\"language\") or \"\").lower().strip()\r\n        if not lang:\r\n            guessed = infer_language_from_path(path)\r\n            if guessed:\r\n                f[\"language\"] = guessed\r\n                lang = guessed\r\n                changes.append(f\"files[{i}].language inferred as '{guessed}'\")\r\n            else:\r\n                f[\"language\"] = \"text\"\r\n                lang = \"text\"\r\n                changes.append(f\"files[{i}].language defaulted to 'text'\")\r\n\r\n        if op in (\"write\", \"patch\"):\r\n            missing = \"contents\" not in f or f.get(\"contents\") is None\r\n            if missing and fill_stubs:\r\n                f[\"contents\"] = stub_for_language(lang)\r\n                changes.append(f\"files[{i}].contents filled with stub for '{lang}'\")\r\n            elif missing:\r\n                errors.append(f\"files[{i}].contents missing for op={op}\")\r\n\r\n        if op == \"rename\":\r\n            if not f.get(\"from\") or not f.get(\"to\"):\r\n                errors.append(f\"files[{i}] missing 'from' or 'to' for op=rename\")\r\n\r\n    return payload, (errors if errors else changes)\r\n\r\ndef main() -> None:\r\n    parser = argparse.ArgumentParser(description=\"Fix common Channel-A payload issues.\")\r\n    parser.add_argument(\"-i\", \"--input\", required=True)\r\n    parser.add_argument(\"-o\", \"--output\")\r\n    parser.add_argument(\"--inplace\", action=\"store_true\")\r\n    parser.add_argument(\"--no-stubs\", dest=\"stubs\", action=\"store_false\")\r\n    parser.add_argument(\r\n        \"--report-json-only\",\r\n        action=\"store_true\",\r\n        help=\"Emit only a JSON report to stdout\",\r\n    )\r\n    args = parser.parse_args()\r\n\r\n    src = Path(args.input)\r\n    if not src.exists():\r\n        print(f\"Input not found: {src}\", file=sys.stderr)\r\n        sys.exit(2)\r\n\r\n    payload = json.loads(src.read_text(encoding=\"utf-8\"))\r\n    fixed, msgs = fix_payload(payload, fill_stubs=args.stubs)\r\n\r\n    if fixed is None:\r\n        report = {\"status\": \"unfixable\", \"input_path\": str(src), \"messages\": msgs}\r\n        print(json.dumps(report, ensure_ascii=False))\r\n        sys.exit(1 if args.report_json_only else 0)\r\n\r\n    if args.inplace and not args.output:\r\n        dst = src\r\n    else:\r\n        dst = Path(args.output) if args.output else src.with_suffix(\".fixed.json\")\r\n\r\n    dst.write_text(json.dumps(fixed, indent=2, ensure_ascii=False), encoding=\"utf-8\")\r\n\r\n    report = {\r\n        \"status\": \"fixed\" if msgs else \"unchanged\",\r\n        \"input_path\": str(src),\r\n        \"output_path\": str(dst),\r\n        \"messages\": msgs,\r\n    }\r\n\r\n    if args.report_json_only:\r\n        print(json.dumps(report, ensure_ascii=False))\r\n    else:\r\n        print(\"Fix report:\")\r\n        for m in msgs:\r\n            print(f\"- {m}\")\r\n        print(f\"Wrote: {dst}\")\r\n\r\nif __name__ == \"__main__\":\r\n    main()\r\n", "after_bytes": "import argparse\nimport json\nimport sys\nfrom pathlib import Path\n\nEXT_TO_LANG = {\n    \".py\": \"python\",\n    \".ps1\": \"powershell\",\n    \".json\": \"json\",\n    \".psm1\": \"powershell\",\n    \".psd1\": \"powershell\",\n    \".cmd\": \"batch\",\n    \".bat\": \"batch\",\n    \".yml\": \"yaml\",\n    \".yaml\": \"yaml\",\n    \".toml\": \"toml\",\n    \".md\": \"markdown\",\n    \".txt\": \"text\"\n}\n\nLANG_STUB = {\n    \"python\": \"pass\\n\",\n    \"powershell\": \"#\\n\",\n    \"json\": \"{}\\n\",\n    \"yaml\": \"#\\n\",\n    \"toml\": \"#\\n\",\n    \"markdown\": \"\\n\",\n    \"text\": \"\\n\",\n    \"batch\": \"REM\\n\"\n}\n\ndef infer_language_from_path(path: str) -> str | None:\n    return EXT_TO_LANG.get(Path(path).suffix.lower())\n\ndef stub_for_language(lang: str) -> str:\n    return LANG_STUB.get(lang, \"\\n\")\n\ndef fix_payload(payload: dict, fill_stubs: bool = True):\n    changes: list[str] = []\n    errors: list[str] = []\n\n    if not isinstance(payload, dict):\n        return None, [\"Payload must be a JSON object\"]\n\n    files = payload.get(\"files\")\n    if not isinstance(files, list):\n        return None, [\"Payload.files must be a list\"]\n\n    for i, f in enumerate(files):\n        if not isinstance(f, dict):\n            errors.append(f\"files[{i}] is not an object\")\n            continue\n\n        path = f.get(\"path\")\n        if not path:\n            errors.append(f\"files[{i}].path missing\")\n            continue\n\n        op = f.get(\"op\")\n        if not op:\n            f[\"op\"] = \"write\"\n            op = \"write\"\n            changes.append(f\"files[{i}].op defaulted to 'write'\")\n\n        lang = (f.get(\"language\") or \"\").lower().strip()\n        if not lang:\n            guessed = infer_language_from_path(path)\n            if guessed:\n                f[\"language\"] = guessed\n                lang = guessed\n                changes.append(f\"files[{i}].language inferred as '{guessed}'\")\n            else:\n                f[\"language\"] = \"text\"\n                lang = \"text\"\n                changes.append(f\"files[{i}].language defaulted to 'text'\")\n\n        if op in (\"write\", \"patch\"):\n            missing = \"contents\" not in f or f.get(\"contents\") is None\n            if missing and fill_stubs:\n                f[\"contents\"] = stub_for_language(lang)\n                changes.append(f\"files[{i}].contents filled with stub for '{lang}'\")\n            elif missing:\n                errors.append(f\"files[{i}].contents missing for op={op}\")\n\n        if op == \"rename\":\n            if not f.get(\"from\") or not f.get(\"to\"):\n                errors.append(f\"files[{i}] missing 'from' or 'to' for op=rename\")\n\n    return payload, (errors if errors else changes)\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(description=\"Fix common Channel-A payload issues.\")\n    parser.add_argument(\"-i\", \"--input\", required=True)\n    parser.add_argument(\"-o\", \"--output\")\n    parser.add_argument(\"--inplace\", action=\"store_true\")\n    parser.add_argument(\"--no-stubs\", dest=\"stubs\", action=\"store_false\")\n    parser.add_argument(\n        \"--report-json-only\",\n        action=\"store_true\",\n        help=\"Emit only a JSON report to stdout\",\n    )\n    args = parser.parse_args()\n\n    src = Path(args.input)\n    if not src.exists():\n        print(f\"Input not found: {src}\", file=sys.stderr)\n        sys.exit(2)\n\n    payload = json.loads(src.read_text(encoding=\"utf-8\"))\n    fixed, msgs = fix_payload(payload, fill_stubs=args.stubs)\n\n    if fixed is None:\n        report = {\"status\": \"unfixable\", \"input_path\": str(src), \"messages\": msgs}\n        print(json.dumps(report, ensure_ascii=False))\n        sys.exit(1 if args.report_json_only else 0)\n\n    if args.inplace and not args.output:\n        dst = src\n    else:\n        dst = Path(args.output) if args.output else src.with_suffix(\".fixed.json\")\n\n    dst.write_text(json.dumps(fixed, indent=2, ensure_ascii=False), encoding=\"utf-8\")\n\n    report = {\n        \"status\": \"fixed\" if msgs else \"unchanged\",\n        \"input_path\": str(src),\n        \"output_path\": str(dst),\n        \"messages\": msgs,\n    }\n\n    if args.report_json_only:\n        print(json.dumps(report, ensure_ascii=False))\n    else:\n        print(\"Fix report:\")\n        for m in msgs:\n            print(f\"- {m}\")\n        print(f\"Wrote: {dst}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"op": "write", "path": "G:\\My Drive\\Code\\Python\\PromptForge\\app.py", "before_sha": "47fc8c5136a23832cf0c09986aa7678daee13fb4a19f2877e3edf19a058e3510", "after_sha": "773f58a23190cc96aec8e75427c616cafe2dc932d45d8f4b9814826270c239aa", "before_bytes": "import hashlib\r\nimport json\r\nimport os\r\nimport re\r\nimport shutil\r\nimport subprocess\r\nimport tempfile\r\nimport webbrowser\r\nfrom pathlib import Path\r\nimport tkinter as tk\r\nfrom tkinter import filedialog, messagebox, ttk\r\n\r\nfrom pf.compliance_gate_t2 import validate as gate_t2_validate\r\nfrom pf.change_journal import prepare_ops_for_apply, record_apply, undo_last\r\n\r\nPROJECT_ROOT = Path.cwd()\r\nSCRIPTS_DIR = PROJECT_ROOT / \"v2\" / \"scripts\"\r\nTOOLS_DIR = PROJECT_ROOT / \"v2\" / \"tools\"\r\n\r\nSCENARIOS = [\r\n    (\"setup_run_ui\", \"scenario_setup_run_ui.ps1\"),\r\n    (\"standard_git_publish\", \"scenario_git_publish.ps1\"),\r\n    (\"standard_test_and_lint\", \"scenario_test_and_lint.ps1\"),\r\n    (\"venv_rebuild\", \"scenario_venv_rebuild.ps1\"),\r\n    (\"venv_validate\", \"scenario_venv_validate.ps1\"),\r\n    (\"tool_commands\", \"scenario_tool_commands.ps1\"),\r\n]\r\n\r\nDEF_EDITOR = os.environ.get(\"PF_EDITOR_CMD\")\r\nPY_EXE = os.environ.get(\"PF_PY\") or shutil.which(\"py\") or shutil.which(\"python\") or \"python\"\r\n\r\nURL_RE = re.compile(r\"(https?://[^\\s\\]\\)]+)\")\r\nPATH_RE = re.compile(\r\n    r\"([A-Za-z]:\\\\[^\\s\\n\\r]+\\.(json|py|ps1|md|txt)|[A-Za-z]:/[^\\s\\n\\r]+\\.(json|py|ps1|md|txt)|/[^\\s\\n\\r]+\\.(json|py|ps1|md|txt))\"\r\n)\r\n\r\n\r\ndef _run_pwsh_script(script_path: Path, *args):\r\n    cmd = [\"pwsh\", \"-NoProfile\", \"-File\", str(script_path), *args]\r\n    return subprocess.run(cmd, capture_output=True, text=True)\r\n\r\n\r\ndef _apply_file(project_root: Path, f: dict):\r\n    op = (f.get(\"op\") or \"write\").lower()\r\n    path = project_root / f[\"path\"]\r\n    path.parent.mkdir(parents=True, exist_ok=True)\r\n    if op == \"write\":\r\n        path.write_text(f.get(\"contents\") or \"\", encoding=\"utf-8\")\r\n    elif op == \"patch\":\r\n        if path.exists():\r\n            existing = path.read_text(encoding=\"utf-8\")\r\n            patch = f.get(\"contents\") or \"\"\r\n            if patch not in existing:\r\n                path.write_text(existing + \"\\n\" + patch, encoding=\"utf-8\")\r\n        else:\r\n            path.write_text(f.get(\"contents\") or \"\", encoding=\"utf-8\")\r\n    elif op == \"delete\":\r\n        if path.exists():\r\n            path.unlink()\r\n    elif op == \"rename\":\r\n        src = f.get(\"from\")\r\n        dst = f.get(\"to\")\r\n        if src and dst:\r\n            (project_root / dst).parent.mkdir(parents=True, exist_ok=True)\r\n            (project_root / src).replace(project_root / dst)\r\n\r\n\r\ndef _basic_schema_validate(payload: dict) -> list[str]:\r\n    errs: list[str] = []\r\n    if not isinstance(payload, dict):\r\n        return [\"Payload must be a JSON object.\"]\r\n    files = payload.get(\"files\")\r\n    if not isinstance(files, list) or not files:\r\n        errs.append(\"Payload.files must be a non-empty list.\")\r\n        return errs\r\n    for i, f in enumerate(files):\r\n        if not isinstance(f, dict):\r\n            errs.append(f\"files[{i}] must be an object.\")\r\n            continue\r\n        for req in (\"path\", \"op\", \"language\"):\r\n            if not f.get(req):\r\n                errs.append(f\"files[{i}].{req} is required.\")\r\n        if f.get(\"op\") not in (\"write\", \"patch\", \"delete\", \"rename\"):\r\n            errs.append(\"files[%d].op must be write|patch|delete|rename.\" % i)\r\n        if f.get(\"op\") in (\"write\", \"patch\") and \"contents\" not in f:\r\n            errs.append(\"files[%d].contents is required for op=%s.\" % (i, f.get(\"op\")))\r\n        if f.get(\"op\") == \"rename\" and (not f.get(\"from\") or not f.get(\"to\")):\r\n            errs.append(\"files[%d].from and .to required for op=rename.\" % i)\r\n    return errs\r\n\r\n\r\nclass App(tk.Tk):\r\n    def __init__(self) -> None:\r\n        super().__init__()\r\n        self.title(\"PromptForge — V2.2 Test Rig\")\r\n        self.geometry(\"1280x860\")\r\n        self.payload: dict | None = None\r\n        self.payload_id: str | None = None\r\n        self.auto_retry = True\r\n\r\n        toolbar = tk.Frame(self)\r\n        toolbar.pack(fill=\"x\", padx=8, pady=6)\r\n        tk.Button(toolbar, text=\"Load JSON\", command=self.load_json).pack(side=\"left\")\r\n        tk.Button(toolbar, text=\"Save JSON\", command=self.save_json).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Validate Schema\", command=self.validate_schema).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Run Compliance\", command=self.run_gate).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Quick Fix\", command=self.quick_fix).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Ruff Fix\", command=self.ruff_fix).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Apply\", command=self.do_apply).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Undo\", command=self.do_undo).pack(side=\"left\", padx=6)\r\n        tk.Button(toolbar, text=\"Retry\", command=self.do_retry).pack(side=\"left\", padx=6)\r\n\r\n        tk.Label(toolbar, text=\"Scenario:\").pack(side=\"left\", padx=(24, 4))\r\n        self.scenario_var = tk.StringVar(value=SCENARIOS[0][0])\r\n        ttk.Combobox(\r\n            toolbar,\r\n            textvariable=self.scenario_var,\r\n            values=[s[0] for s in SCENARIOS],\r\n            width=28,\r\n        ).pack(side=\"left\")\r\n        tk.Button(toolbar, text=\"Run Scenario\", command=self.run_scenario).pack(side=\"left\", padx=6)\r\n\r\n        paned = tk.PanedWindow(self, sashrelief=\"raised\", orient=\"horizontal\")\r\n        paned.pack(expand=True, fill=\"both\")\r\n        left = tk.PanedWindow(paned, orient=\"vertical\")\r\n        right = tk.PanedWindow(paned, orient=\"vertical\")\r\n        paned.add(left)\r\n        paned.add(right)\r\n\r\n        self.txt_parsed = self._panel(left, \"Parsed A (Channel-A JSON)\")\r\n        self.txt_prose = self._panel(left, \"Prose B (human narrative)\")\r\n        self.txt_errors = self._panel(right, \"Errors / Logs\")\r\n\r\n        self._log(\"Project root: \" + str(PROJECT_ROOT))\r\n\r\n    def _panel(self, parent, title: str) -> tk.Text:\r\n        frame = tk.Frame(parent)\r\n        parent.add(frame)\r\n        tk.Label(frame, text=title, anchor=\"w\").pack(fill=\"x\")\r\n        text = tk.Text(frame, wrap=\"word\", undo=True)\r\n        text.pack(expand=True, fill=\"both\")\r\n        return text\r\n\r\n    def _linkify(self, widget: tk.Text) -> None:\r\n        content = widget.get(\"1.0\", \"end\")\r\n        for match in URL_RE.finditer(content):\r\n            self._tag_link(widget, match.start(), match.end(), match.group(1))\r\n        for match in PATH_RE.finditer(content):\r\n            self._tag_link(widget, match.start(1), match.end(1), match.group(1))\r\n\r\n    def _tag_link(self, widget: tk.Text, start: int, end: int, target: str) -> None:\r\n        s = self._idx_to_text_index(widget, start)\r\n        e = self._idx_to_text_index(widget, end)\r\n        tag = f\"link_{start}_{end}\"\r\n        widget.tag_add(tag, s, e)\r\n        widget.tag_config(tag, foreground=\"blue\", underline=True)\r\n        widget.tag_bind(tag, \"<Button-1>\", lambda _e, t=target: self._open_target(t))\r\n\r\n    def _idx_to_text_index(self, widget: tk.Text, n: int) -> str:\r\n        content = widget.get(\"1.0\", \"end\")\r\n        before = content[:n]\r\n        line = before.count(\"\\n\") + 1\r\n        col = len(before.rsplit(\"\\n\", 1)[-1]) + 1\r\n        return f\"{line}.{col}\"\r\n\r\n    def _open_target(self, target: str) -> None:\r\n        val = target.strip()\r\n        if val.startswith(\"http://\") or val.startswith(\"https://\"):\r\n            webbrowser.open(val)\r\n            return\r\n        path = Path(val)\r\n        if DEF_EDITOR:\r\n            cmd = DEF_EDITOR.format(path=str(path)) if \"{path}\" in DEF_EDITOR else f\"{DEF_EDITOR} {path}\"\r\n            subprocess.Popen(cmd, shell=True)\r\n            return\r\n        if shutil.which(\"code\"):\r\n            subprocess.Popen([\"code\", \"-g\", str(path)])\r\n        elif os.name == \"nt\":\r\n            os.startfile(str(path))  # type: ignore[attr-defined]\r\n        else:\r\n            subprocess.Popen([\"xdg-open\", str(path)])\r\n\r\n    def _log(self, msg: str) -> None:\r\n        self.txt_errors.insert(\"end\", msg + \"\\n\")\r\n        self.txt_errors.see(\"end\")\r\n        self._linkify(self.txt_errors)\r\n\r\n    def _prose(self, msg: str) -> None:\r\n        self.txt_prose.insert(\"end\", msg + \"\\n\")\r\n        self.txt_prose.see(\"end\")\r\n        self._linkify(self.txt_prose)\r\n\r\n    def load_json(self) -> None:\r\n        path = filedialog.askopenfilename(\r\n            title=\"Select Channel-A JSON\",\r\n            filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")],\r\n        )\r\n        if not path:\r\n            return\r\n        with open(path, \"r\", encoding=\"utf-8\") as handle:\r\n            self.payload = json.load(handle)\r\n        self.txt_parsed.delete(\"1.0\", \"end\")\r\n        self.txt_parsed.insert(\"1.0\", json.dumps(self.payload, indent=2, ensure_ascii=False))\r\n        self._log(f\"Loaded payload: {path}\")\r\n\r\n    def save_json(self) -> None:\r\n        if not self.payload:\r\n            try:\r\n                self.payload = json.loads(self.txt_parsed.get(\"1.0\", \"end\").strip())\r\n            except Exception as exc:\r\n                messagebox.showerror(\"Save JSON\", f\"No valid JSON loaded/typed.\\n{exc}\")\r\n                return\r\n        dest = filedialog.asksaveasfilename(\r\n            defaultextension=\".json\", filetypes=[(\"JSON\", \"*.json\")]\r\n        )\r\n        if not dest:\r\n            return\r\n        with open(dest, \"w\", encoding=\"utf-8\") as handle:\r\n            json.dump(self.payload, handle, indent=2, ensure_ascii=False)\r\n        self._log(f\"Saved payload: {dest}\")\r\n\r\n    def _read_payload_from_editor(self) -> dict | None:\r\n        try:\r\n            return json.loads(self.txt_parsed.get(\"1.0\", \"end\").strip())\r\n        except Exception as exc:\r\n            messagebox.showerror(\"Invalid JSON\", str(exc))\r\n            return None\r\n\r\n    def _compute_payload_id(self, payload: dict) -> str:\r\n        norm = json.dumps(payload, sort_keys=True, ensure_ascii=False)\r\n        return hashlib.sha256(norm.encode(\"utf-8\")).hexdigest()[:8]\r\n\r\n    def validate_schema(self) -> None:\r\n        payload = self._read_payload_from_editor()\r\n        if not payload:\r\n            return\r\n        errs = _basic_schema_validate(payload)\r\n        if errs:\r\n            self._log(\"SCHEMA: FAIL\")\r\n            for e in errs:\r\n                self._log(\" - \" + e)\r\n            messagebox.showerror(\"Schema\", \"FAIL — see Errors panel\")\r\n        else:\r\n            self.payload_id = self._compute_payload_id(payload)\r\n            msg = f\"SCHEMA: PASS — PayloadID: {self.payload_id}\"\r\n            self._log(msg)\r\n            self._prose(msg)\r\n            messagebox.showinfo(\"Schema\", msg)\r\n        self.payload = payload\r\n\r\n    def run_gate(self) -> None:\r\n        payload = self._read_payload_from_editor()\r\n        if not payload:\r\n            return\r\n        res = gate_t2_validate(payload)\r\n        if res[\"pass\"]:\r\n            self._log(\"Compliance Gate: PASS\")\r\n            messagebox.showinfo(\"Compliance\", \"PASS\")\r\n        else:\r\n            self._log(\"Compliance Gate: FAIL\")\r\n            for e in res[\"errors\"]:\r\n                self._log(e)\r\n            messagebox.showerror(\"Compliance\", \"FAIL — see Errors panel\")\r\n        self.payload = payload\r\n\r\n    def quick_fix(self) -> None:\r\n        raw = self.txt_parsed.get(\"1.0\", \"end\").strip()\r\n        if not raw:\r\n            messagebox.showerror(\"Quick Fix\", \"No JSON in Parsed panel.\")\r\n            return\r\n        try:\r\n            json.loads(raw)\r\n        except Exception:\r\n            messagebox.showerror(\"Quick Fix\", \"Invalid JSON in Parsed panel.\")\r\n            return\r\n        tmp_in = PROJECT_ROOT / \"v2\" / \"samples\" / \"_last_fix_input.json\"\r\n        tmp_out = PROJECT_ROOT / \"v2\" / \"samples\" / \"_last_fix_input.fixed.json\"\r\n        tmp_in.parent.mkdir(parents=True, exist_ok=True)\r\n        tmp_in.write_text(raw, encoding=\"utf-8\")\r\n\r\n        fixer = TOOLS_DIR / \"fix_channel_a.py\"\r\n        if not fixer.exists():\r\n            messagebox.showerror(\"Quick Fix\", f\"Missing fixer: {fixer}\")\r\n            return\r\n\r\n        if str(PY_EXE).endswith(\"py\") or str(PY_EXE).endswith(\"py.exe\"):\r\n            cmd = [PY_EXE, \"-3.12\", str(fixer), \"-i\", str(tmp_in), \"-o\", str(tmp_out), \"--report-json-only\"]\r\n        else:\r\n            cmd = [PY_EXE, str(fixer), \"-i\", str(tmp_in), \"-o\", str(tmp_out), \"--report-json-only\"]\r\n        proc = subprocess.run(cmd, capture_output=True, text=True)\r\n        if proc.returncode not in (0,):\r\n            self._log(\"Quick Fix failed:\")\r\n            self._log(proc.stdout)\r\n            self._log(proc.stderr)\r\n            messagebox.showerror(\"Quick Fix\", \"Failed — see Errors panel\")\r\n            return\r\n        try:\r\n            report = json.loads(proc.stdout.strip() or \"{}\")\r\n        except Exception:\r\n            report = {\"status\": \"unknown\", \"messages\": [proc.stdout.strip()]}\r\n\r\n        status = report.get(\"status\", \"unknown\")\r\n        outp = report.get(\"output_path\", str(tmp_out))\r\n        msgs = report.get(\"messages\", [])\r\n\r\n        if Path(outp).exists():\r\n            fixed = json.loads(Path(outp).read_text(encoding=\"utf-8\"))\r\n            self.payload = fixed\r\n            self.txt_parsed.delete(\"1.0\", \"end\")\r\n            self.txt_parsed.insert(\"1.0\", json.dumps(fixed, indent=2, ensure_ascii=False))\r\n\r\n        changed = [m for m in msgs if (\"defaulted\" in m or \"inferred\" in m or \"filled\" in m)]\r\n        prose_msg = f\"Quick Fix: {status.upper()}. Wrote: {outp}\"\r\n        if changed:\r\n            prose_msg += \"\\nChanges:\\n - \" + \"\\n - \".join(changed)\r\n        self._prose(prose_msg)\r\n        self._log(\"Quick Fix report: \" + json.dumps(report, ensure_ascii=False))\r\n        messagebox.showinfo(\"Quick Fix\", f\"Fixed payload written to:\\n{outp}\")\r\n\r\n    def ruff_fix(self) -> None:\r\n        payload = self._read_payload_from_editor()\r\n        if not payload:\r\n            return\r\n        ruff = shutil.which(\"ruff\")\r\n        if not ruff:\r\n            messagebox.showerror(\"Ruff Fix\", \"ruff is not on PATH.\")\r\n            return\r\n        tmpdir = Path(tempfile.mkdtemp(prefix=\"pf_rufffix_\"))\r\n        changed_count = 0\r\n        details: list[str] = []\r\n        for idx, f in enumerate(payload.get(\"files\", [])):\r\n            lang = (f.get(\"language\") or \"\").lower()\r\n            src = f.get(\"contents\")\r\n            if lang not in (\"python\", \"py\") or src is None:\r\n                continue\r\n            tpath = tmpdir / f\"snippet_{idx}.py\"\r\n            tpath.write_text(src, encoding=\"utf-8\")\r\n            subprocess.run([ruff, \"check\", \"--fix\", str(tpath)], capture_output=True, text=True)\r\n            new_src = tpath.read_text(encoding=\"utf-8\")\r\n            if new_src != src:\r\n                payload[\"files\"][idx][\"contents\"] = new_src\r\n                changed_count += 1\r\n                details.append(f\"files[{idx}] fixed via ruff --fix -> {tpath.name}\")\r\n        if changed_count:\r\n            self.payload = payload\r\n            self.txt_parsed.delete(\"1.0\", \"end\")\r\n            self.txt_parsed.insert(\"1.0\", json.dumps(payload, indent=2, ensure_ascii=False))\r\n            msg = f\"Ruff Fix: updated {changed_count} Python file(s) in payload.\"\r\n            self._prose(msg)\r\n            self._log(\"; \".join(details))\r\n            messagebox.showinfo(\"Ruff Fix\", msg)\r\n        else:\r\n            messagebox.showinfo(\"Ruff Fix\", \"No Python files changed.\")\r\n\r\n    def do_apply(self) -> None:\r\n        payload = self._read_payload_from_editor()\r\n        if not payload:\r\n            return\r\n        s_errs = _basic_schema_validate(payload)\r\n        if s_errs:\r\n            self._log(\"Apply blocked — schema invalid.\")\r\n            for e in s_errs:\r\n                self._log(\" - \" + e)\r\n            messagebox.showerror(\"Apply\", \"Blocked by Schema.\")\r\n            return\r\n        res = gate_t2_validate(payload)\r\n        if not res[\"pass\"]:\r\n            self._log(\"Apply blocked — compliance failed.\")\r\n            for e in res[\"errors\"]:\r\n                self._log(e)\r\n            if self.auto_retry:\r\n                self._log(\"Auto-retry available via Retry button.\")\r\n            messagebox.showerror(\"Apply\", \"Blocked by Compliance Gate.\")\r\n            return\r\n        files = payload.get(\"files\", [])\r\n        ops = prepare_ops_for_apply(PROJECT_ROOT, files)\r\n        for f in files:\r\n            _apply_file(PROJECT_ROOT, f)\r\n        jf = record_apply(PROJECT_ROOT, ops)\r\n        journal_id = jf.stem\r\n        msg = f\"APPLY: PASS — JournalID: {journal_id}\\nPath: {jf}\"\r\n        self._log(msg)\r\n        self._prose(msg)\r\n        messagebox.showinfo(\"Apply\", msg)\r\n        self.payload = payload\r\n\r\n    def do_undo(self) -> None:\r\n        res = undo_last(PROJECT_ROOT)\r\n        if res.get(\"ok\"):\r\n            self._log(res[\"message\"])\r\n            messagebox.showinfo(\"Undo\", res[\"message\"])\r\n        else:\r\n            self._log(res[\"message\"])\r\n            messagebox.showwarning(\"Undo\", res[\"message\"])\r\n\r\n    def do_retry(self) -> None:\r\n        if not self.payload:\r\n            self._log(\"Nothing to retry.\")\r\n            return\r\n        res = gate_t2_validate(self.payload)\r\n        if res[\"pass\"]:\r\n            self._log(\"Retry: Compliance Gate now PASS\")\r\n        else:\r\n            self._log(\"Retry: still FAIL\")\r\n            for e in res[\"errors\"]:\r\n                self._log(e)\r\n\r\n    def run_scenario(self) -> None:\r\n        name = self.scenario_var.get()\r\n        match = next((m for m in SCENARIOS if m[0] == name), None)\r\n        if not match:\r\n            messagebox.showerror(\"Scenario\", f\"Unknown scenario: {name}\")\r\n            return\r\n        script = SCRIPTS_DIR / match[1]\r\n        if not script.exists():\r\n            self._log(f\"Scenario script not found: {script}\")\r\n            messagebox.showerror(\"Scenario\", f\"Missing: {script.name}\")\r\n            return\r\n        result = _run_pwsh_script(script, \"-ProjectRoot\", str(PROJECT_ROOT))\r\n        if result.returncode == 0:\r\n            self._log(f\"[{name}] OK\")\r\n            if result.stdout.strip():\r\n                self._log(result.stdout.strip())\r\n            messagebox.showinfo(\"Scenario\", f\"{name}: OK\")\r\n        else:\r\n            self._log(f\"[{name}] FAIL ({result.returncode})\")\r\n            if result.stdout.strip():\r\n                self._log(result.stdout.strip())\r\n            if result.stderr.strip():\r\n                self._log(result.stderr.strip())\r\n            messagebox.showerror(\"Scenario\", f\"{name}: FAIL — see Errors panel\")\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    App().mainloop()\r\n", "after_bytes": "import hashlib\nimport json\nimport os\nimport re\nimport shutil\nimport subprocess\nimport tempfile\nimport webbrowser\nfrom pathlib import Path\nimport tkinter as tk\nfrom tkinter import filedialog, messagebox, ttk\n\nfrom pf.compliance_gate_t2 import validate as gate_t2_validate\nfrom pf.change_journal import prepare_ops_for_apply, record_apply, undo_last\n\nPROJECT_ROOT = Path.cwd()\nSCRIPTS_DIR = PROJECT_ROOT / \"v2\" / \"scripts\"\nTOOLS_DIR = PROJECT_ROOT / \"v2\" / \"tools\"\n\nSCENARIOS = [\n    (\"setup_run_ui\", \"scenario_setup_run_ui.ps1\"),\n    (\"standard_git_publish\", \"scenario_git_publish.ps1\"),\n    (\"standard_test_and_lint\", \"scenario_test_and_lint.ps1\"),\n    (\"venv_rebuild\", \"scenario_venv_rebuild.ps1\"),\n    (\"venv_validate\", \"scenario_venv_validate.ps1\"),\n    (\"tool_commands\", \"scenario_tool_commands.ps1\"),\n]\n\nDEF_EDITOR = os.environ.get(\"PF_EDITOR_CMD\")\nPY_EXE = os.environ.get(\"PF_PY\") or shutil.which(\"py\") or shutil.which(\"python\") or \"python\"\n\nURL_RE = re.compile(r\"(https?://[^\\s\\]\\)]+)\")\nPATH_RE = re.compile(\n    r\"([A-Za-z]:\\\\[^\\s\\n\\r]+\\.(json|py|ps1|md|txt)|[A-Za-z]:/[^\\s\\n\\r]+\\.(json|py|ps1|md|txt)|/[^\\s\\n\\r]+\\.(json|py|ps1|md|txt))\"\n)\n\n\ndef _run_pwsh_script(script_path: Path, *args):\n    cmd = [\"pwsh\", \"-NoProfile\", \"-File\", str(script_path), *args]\n    return subprocess.run(cmd, capture_output=True, text=True)\n\n\ndef _apply_file(project_root: Path, f: dict):\n    op = (f.get(\"op\") or \"write\").lower()\n    path = project_root / f[\"path\"]\n    path.parent.mkdir(parents=True, exist_ok=True)\n    if op == \"write\":\n        path.write_text(f.get(\"contents\") or \"\", encoding=\"utf-8\")\n    elif op == \"patch\":\n        if path.exists():\n            existing = path.read_text(encoding=\"utf-8\")\n            patch = f.get(\"contents\") or \"\"\n            if patch not in existing:\n                path.write_text(existing + \"\\n\" + patch, encoding=\"utf-8\")\n        else:\n            path.write_text(f.get(\"contents\") or \"\", encoding=\"utf-8\")\n    elif op == \"delete\":\n        if path.exists():\n            path.unlink()\n    elif op == \"rename\":\n        src = f.get(\"from\")\n        dst = f.get(\"to\")\n        if src and dst:\n            (project_root / dst).parent.mkdir(parents=True, exist_ok=True)\n            (project_root / src).replace(project_root / dst)\n\n\ndef _basic_schema_validate(payload: dict) -> list[str]:\n    errs: list[str] = []\n    if not isinstance(payload, dict):\n        return [\"Payload must be a JSON object.\"]\n    files = payload.get(\"files\")\n    if not isinstance(files, list) or not files:\n        errs.append(\"Payload.files must be a non-empty list.\")\n        return errs\n    for i, f in enumerate(files):\n        if not isinstance(f, dict):\n            errs.append(f\"files[{i}] must be an object.\")\n            continue\n        for req in (\"path\", \"op\", \"language\"):\n            if not f.get(req):\n                errs.append(f\"files[{i}].{req} is required.\")\n        if f.get(\"op\") not in (\"write\", \"patch\", \"delete\", \"rename\"):\n            errs.append(\"files[%d].op must be write|patch|delete|rename.\" % i)\n        if f.get(\"op\") in (\"write\", \"patch\") and \"contents\" not in f:\n            errs.append(\"files[%d].contents is required for op=%s.\" % (i, f.get(\"op\")))\n        if f.get(\"op\") == \"rename\" and (not f.get(\"from\") or not f.get(\"to\")):\n            errs.append(\"files[%d].from and .to required for op=rename.\" % i)\n    return errs\n\n\nclass App(tk.Tk):\n    def __init__(self) -> None:\n        super().__init__()\n        self.title(\"PromptForge — V2.2 Test Rig\")\n        self.geometry(\"1280x860\")\n        self.payload: dict | None = None\n        self.payload_id: str | None = None\n        self.auto_retry = True\n\n        toolbar = tk.Frame(self)\n        toolbar.pack(fill=\"x\", padx=8, pady=6)\n        tk.Button(toolbar, text=\"Load JSON\", command=self.load_json).pack(side=\"left\")\n        tk.Button(toolbar, text=\"Save JSON\", command=self.save_json).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Validate Schema\", command=self.validate_schema).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Run Compliance\", command=self.run_gate).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Quick Fix\", command=self.quick_fix).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Ruff Fix\", command=self.ruff_fix).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Apply\", command=self.do_apply).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Undo\", command=self.do_undo).pack(side=\"left\", padx=6)\n        tk.Button(toolbar, text=\"Retry\", command=self.do_retry).pack(side=\"left\", padx=6)\n\n        tk.Label(toolbar, text=\"Scenario:\").pack(side=\"left\", padx=(24, 4))\n        self.scenario_var = tk.StringVar(value=SCENARIOS[0][0])\n        ttk.Combobox(\n            toolbar,\n            textvariable=self.scenario_var,\n            values=[s[0] for s in SCENARIOS],\n            width=28,\n        ).pack(side=\"left\")\n        tk.Button(toolbar, text=\"Run Scenario\", command=self.run_scenario).pack(side=\"left\", padx=6)\n\n        paned = tk.PanedWindow(self, sashrelief=\"raised\", orient=\"horizontal\")\n        paned.pack(expand=True, fill=\"both\")\n        left = tk.PanedWindow(paned, orient=\"vertical\")\n        right = tk.PanedWindow(paned, orient=\"vertical\")\n        paned.add(left)\n        paned.add(right)\n\n        self.txt_parsed = self._panel(left, \"Parsed A (Channel-A JSON)\")\n        self.txt_prose = self._panel(left, \"Prose B (human narrative)\")\n        self.txt_errors = self._panel(right, \"Errors / Logs\")\n\n        self._log(\"Project root: \" + str(PROJECT_ROOT))\n\n    def _panel(self, parent, title: str) -> tk.Text:\n        frame = tk.Frame(parent)\n        parent.add(frame)\n        tk.Label(frame, text=title, anchor=\"w\").pack(fill=\"x\")\n        text = tk.Text(frame, wrap=\"word\", undo=True)\n        text.pack(expand=True, fill=\"both\")\n        return text\n\n    def _linkify(self, widget: tk.Text) -> None:\n        content = widget.get(\"1.0\", \"end\")\n        for match in URL_RE.finditer(content):\n            self._tag_link(widget, match.start(), match.end(), match.group(1))\n        for match in PATH_RE.finditer(content):\n            self._tag_link(widget, match.start(1), match.end(1), match.group(1))\n\n    def _tag_link(self, widget: tk.Text, start: int, end: int, target: str) -> None:\n        s = self._idx_to_text_index(widget, start)\n        e = self._idx_to_text_index(widget, end)\n        tag = f\"link_{start}_{end}\"\n        widget.tag_add(tag, s, e)\n        widget.tag_config(tag, foreground=\"blue\", underline=True)\n        widget.tag_bind(tag, \"<Button-1>\", lambda _e, t=target: self._open_target(t))\n\n    def _idx_to_text_index(self, widget: tk.Text, n: int) -> str:\n        content = widget.get(\"1.0\", \"end\")\n        before = content[:n]\n        line = before.count(\"\\n\") + 1\n        col = len(before.rsplit(\"\\n\", 1)[-1]) + 1\n        return f\"{line}.{col}\"\n\n    def _open_target(self, target: str) -> None:\n        val = target.strip()\n        if val.startswith(\"http://\") or val.startswith(\"https://\"):\n            webbrowser.open(val)\n            return\n        path = Path(val)\n        if DEF_EDITOR:\n            cmd = DEF_EDITOR.format(path=str(path)) if \"{path}\" in DEF_EDITOR else f\"{DEF_EDITOR} {path}\"\n            subprocess.Popen(cmd, shell=True)\n            return\n        if shutil.which(\"code\"):\n            subprocess.Popen([\"code\", \"-g\", str(path)])\n        elif os.name == \"nt\":\n            os.startfile(str(path))  # type: ignore[attr-defined]\n        else:\n            subprocess.Popen([\"xdg-open\", str(path)])\n\n    def _log(self, msg: str) -> None:\n        self.txt_errors.insert(\"end\", msg + \"\\n\")\n        self.txt_errors.see(\"end\")\n        self._linkify(self.txt_errors)\n\n    def _prose(self, msg: str) -> None:\n        self.txt_prose.insert(\"end\", msg + \"\\n\")\n        self.txt_prose.see(\"end\")\n        self._linkify(self.txt_prose)\n\n    def load_json(self) -> None:\n        path = filedialog.askopenfilename(\n            title=\"Select Channel-A JSON\",\n            filetypes=[(\"JSON files\", \"*.json\"), (\"All files\", \"*.*\")],\n        )\n        if not path:\n            return\n        with open(path, \"r\", encoding=\"utf-8\") as handle:\n            self.payload = json.load(handle)\n        self.txt_parsed.delete(\"1.0\", \"end\")\n        self.txt_parsed.insert(\"1.0\", json.dumps(self.payload, indent=2, ensure_ascii=False))\n        self._log(f\"Loaded payload: {path}\")\n\n    def save_json(self) -> None:\n        if not self.payload:\n            try:\n                self.payload = json.loads(self.txt_parsed.get(\"1.0\", \"end\").strip())\n            except Exception as exc:\n                messagebox.showerror(\"Save JSON\", f\"No valid JSON loaded/typed.\\n{exc}\")\n                return\n        dest = filedialog.asksaveasfilename(\n            defaultextension=\".json\", filetypes=[(\"JSON\", \"*.json\")]\n        )\n        if not dest:\n            return\n        with open(dest, \"w\", encoding=\"utf-8\") as handle:\n            json.dump(self.payload, handle, indent=2, ensure_ascii=False)\n        self._log(f\"Saved payload: {dest}\")\n\n    def _read_payload_from_editor(self) -> dict | None:\n        try:\n            return json.loads(self.txt_parsed.get(\"1.0\", \"end\").strip())\n        except Exception as exc:\n            messagebox.showerror(\"Invalid JSON\", str(exc))\n            return None\n\n    def _compute_payload_id(self, payload: dict) -> str:\n        norm = json.dumps(payload, sort_keys=True, ensure_ascii=False)\n        return hashlib.sha256(norm.encode(\"utf-8\")).hexdigest()[:8]\n\n    def validate_schema(self) -> None:\n        payload = self._read_payload_from_editor()\n        if not payload:\n            return\n        errs = _basic_schema_validate(payload)\n        if errs:\n            self._log(\"SCHEMA: FAIL\")\n            for e in errs:\n                self._log(\" - \" + e)\n            messagebox.showerror(\"Schema\", \"FAIL — see Errors panel\")\n        else:\n            self.payload_id = self._compute_payload_id(payload)\n            msg = f\"SCHEMA: PASS — PayloadID: {self.payload_id}\"\n            self._log(msg)\n            self._prose(msg)\n            messagebox.showinfo(\"Schema\", msg)\n        self.payload = payload\n\n    def run_gate(self) -> None:\n        payload = self._read_payload_from_editor()\n        if not payload:\n            return\n        res = gate_t2_validate(payload)\n        if res[\"pass\"]:\n            self._log(\"Compliance Gate: PASS\")\n            messagebox.showinfo(\"Compliance\", \"PASS\")\n        else:\n            self._log(\"Compliance Gate: FAIL\")\n            for e in res[\"errors\"]:\n                self._log(e)\n            messagebox.showerror(\"Compliance\", \"FAIL — see Errors panel\")\n        self.payload = payload\n\n    def quick_fix(self) -> None:\n        raw = self.txt_parsed.get(\"1.0\", \"end\").strip()\n        if not raw:\n            messagebox.showerror(\"Quick Fix\", \"No JSON in Parsed panel.\")\n            return\n        try:\n            json.loads(raw)\n        except Exception:\n            messagebox.showerror(\"Quick Fix\", \"Invalid JSON in Parsed panel.\")\n            return\n        tmp_in = PROJECT_ROOT / \"v2\" / \"samples\" / \"_last_fix_input.json\"\n        tmp_out = PROJECT_ROOT / \"v2\" / \"samples\" / \"_last_fix_input.fixed.json\"\n        tmp_in.parent.mkdir(parents=True, exist_ok=True)\n        tmp_in.write_text(raw, encoding=\"utf-8\")\n\n        fixer = TOOLS_DIR / \"fix_channel_a.py\"\n        if not fixer.exists():\n            messagebox.showerror(\"Quick Fix\", f\"Missing fixer: {fixer}\")\n            return\n\n        if str(PY_EXE).endswith(\"py\") or str(PY_EXE).endswith(\"py.exe\"):\n            cmd = [PY_EXE, \"-3.12\", str(fixer), \"-i\", str(tmp_in), \"-o\", str(tmp_out), \"--report-json-only\"]\n        else:\n            cmd = [PY_EXE, str(fixer), \"-i\", str(tmp_in), \"-o\", str(tmp_out), \"--report-json-only\"]\n        proc = subprocess.run(cmd, capture_output=True, text=True)\n        if proc.returncode not in (0,):\n            self._log(\"Quick Fix failed:\")\n            self._log(proc.stdout)\n            self._log(proc.stderr)\n            messagebox.showerror(\"Quick Fix\", \"Failed — see Errors panel\")\n            return\n        try:\n            report = json.loads(proc.stdout.strip() or \"{}\")\n        except Exception:\n            report = {\"status\": \"unknown\", \"messages\": [proc.stdout.strip()]}\n\n        status = report.get(\"status\", \"unknown\")\n        outp = report.get(\"output_path\", str(tmp_out))\n        msgs = report.get(\"messages\", [])\n\n        if Path(outp).exists():\n            fixed = json.loads(Path(outp).read_text(encoding=\"utf-8\"))\n            self.payload = fixed\n            self.txt_parsed.delete(\"1.0\", \"end\")\n            self.txt_parsed.insert(\"1.0\", json.dumps(fixed, indent=2, ensure_ascii=False))\n\n        changed = [m for m in msgs if (\"defaulted\" in m or \"inferred\" in m or \"filled\" in m)]\n        prose_msg = f\"Quick Fix: {status.upper()}. Wrote: {outp}\"\n        if changed:\n            prose_msg += \"\\nChanges:\\n - \" + \"\\n - \".join(changed)\n        self._prose(prose_msg)\n        self._log(\"Quick Fix report: \" + json.dumps(report, ensure_ascii=False))\n        messagebox.showinfo(\"Quick Fix\", f\"Fixed payload written to:\\n{outp}\")\n\n    def ruff_fix(self) -> None:\n        payload = self._read_payload_from_editor()\n        if not payload:\n            return\n        ruff = shutil.which(\"ruff\")\n        if not ruff:\n            messagebox.showerror(\"Ruff Fix\", \"ruff is not on PATH.\")\n            return\n        tmpdir = Path(tempfile.mkdtemp(prefix=\"pf_rufffix_\"))\n        changed_count = 0\n        details: list[str] = []\n        for idx, f in enumerate(payload.get(\"files\", [])):\n            lang = (f.get(\"language\") or \"\").lower()\n            src = f.get(\"contents\")\n            if lang not in (\"python\", \"py\") or src is None:\n                continue\n            tpath = tmpdir / f\"snippet_{idx}.py\"\n            tpath.write_text(src, encoding=\"utf-8\")\n            subprocess.run([ruff, \"check\", \"--fix\", str(tpath)], capture_output=True, text=True)\n            new_src = tpath.read_text(encoding=\"utf-8\")\n            if new_src != src:\n                payload[\"files\"][idx][\"contents\"] = new_src\n                changed_count += 1\n                details.append(f\"files[{idx}] fixed via ruff --fix -> {tpath.name}\")\n        if changed_count:\n            self.payload = payload\n            self.txt_parsed.delete(\"1.0\", \"end\")\n            self.txt_parsed.insert(\"1.0\", json.dumps(payload, indent=2, ensure_ascii=False))\n            msg = f\"Ruff Fix: updated {changed_count} Python file(s) in payload.\"\n            self._prose(msg)\n            self._log(\"; \".join(details))\n            messagebox.showinfo(\"Ruff Fix\", msg)\n        else:\n            messagebox.showinfo(\"Ruff Fix\", \"No Python files changed.\")\n\n    def do_apply(self) -> None:\n        payload = self._read_payload_from_editor()\n        if not payload:\n            return\n        s_errs = _basic_schema_validate(payload)\n        if s_errs:\n            self._log(\"Apply blocked — schema invalid.\")\n            for e in s_errs:\n                self._log(\" - \" + e)\n            messagebox.showerror(\"Apply\", \"Blocked by Schema.\")\n            return\n        res = gate_t2_validate(payload)\n        if not res[\"pass\"]:\n            self._log(\"Apply blocked — compliance failed.\")\n            for e in res[\"errors\"]:\n                self._log(e)\n            if self.auto_retry:\n                self._log(\"Auto-retry available via Retry button.\")\n            messagebox.showerror(\"Apply\", \"Blocked by Compliance Gate.\")\n            return\n        files = payload.get(\"files\", [])\n        ops = prepare_ops_for_apply(PROJECT_ROOT, files)\n        for f in files:\n            _apply_file(PROJECT_ROOT, f)\n        jf = record_apply(PROJECT_ROOT, ops)\n        journal_id = jf.stem\n        msg = f\"APPLY: PASS — JournalID: {journal_id}\\nPath: {jf}\"\n        self._log(msg)\n        self._prose(msg)\n        messagebox.showinfo(\"Apply\", msg)\n        self.payload = payload\n\n    def do_undo(self) -> None:\n        res = undo_last(PROJECT_ROOT)\n        if res.get(\"ok\"):\n            self._log(res[\"message\"])\n            messagebox.showinfo(\"Undo\", res[\"message\"])\n        else:\n            self._log(res[\"message\"])\n            messagebox.showwarning(\"Undo\", res[\"message\"])\n\n    def do_retry(self) -> None:\n        if not self.payload:\n            self._log(\"Nothing to retry.\")\n            return\n        res = gate_t2_validate(self.payload)\n        if res[\"pass\"]:\n            self._log(\"Retry: Compliance Gate now PASS\")\n        else:\n            self._log(\"Retry: still FAIL\")\n            for e in res[\"errors\"]:\n                self._log(e)\n\n    def run_scenario(self) -> None:\n        name = self.scenario_var.get()\n        match = next((m for m in SCENARIOS if m[0] == name), None)\n        if not match:\n            messagebox.showerror(\"Scenario\", f\"Unknown scenario: {name}\")\n            return\n        script = SCRIPTS_DIR / match[1]\n        if not script.exists():\n            self._log(f\"Scenario script not found: {script}\")\n            messagebox.showerror(\"Scenario\", f\"Missing: {script.name}\")\n            return\n        result = _run_pwsh_script(script, \"-ProjectRoot\", str(PROJECT_ROOT))\n        if result.returncode == 0:\n            self._log(f\"[{name}] OK\")\n            if result.stdout.strip():\n                self._log(result.stdout.strip())\n            messagebox.showinfo(\"Scenario\", f\"{name}: OK\")\n        else:\n            self._log(f\"[{name}] FAIL ({result.returncode})\")\n            if result.stdout.strip():\n                self._log(result.stdout.strip())\n            if result.stderr.strip():\n                self._log(result.stderr.strip())\n            messagebox.showerror(\"Scenario\", f\"{name}: FAIL — see Errors panel\")\n\n\nif __name__ == \"__main__\":\n    App().mainloop()\n"}
